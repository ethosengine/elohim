/**
 * Generate TypeScript types from Rust DNA schema
 *
 * This script reads the JSON output from hc-rna-schema --export-enums and
 * generates TypeScript const arrays that match the Rust validation constants.
 *
 * Usage:
 *   npx tsx src/generate-schema-types.ts < schema-enums.json
 *   OR
 *   npx tsx src/generate-schema-types.ts --input schema-enums.json
 *
 * Output: src/generated/schema-enums.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_DIR = path.join(__dirname, 'generated');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'schema-enums.ts');

interface SchemaEnums {
  [key: string]: string[];
}

function toConstantName(snakeName: string): string {
  return snakeName.toUpperCase();
}

function toTypeName(snakeName: string): string {
  // snake_case to PascalCase
  return snakeName
    .split('_')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function generateTypeScript(enums: SchemaEnums): string {
  const lines: string[] = [
    '/**',
    ' * Generated validation constants from Rust DNA schema',
    ' *',
    ' * DO NOT EDIT - This file is auto-generated by generate-schema-types.ts',
    ' * Source: holochain/dna/elohim/zomes/content_store_integrity/src/healing.rs',
    ' *',
    ` * Generated: ${new Date().toISOString()}`,
    ' */',
    '',
  ];

  const sortedKeys = Object.keys(enums).sort();

  for (const key of sortedKeys) {
    const values = enums[key];
    const constName = toConstantName(key);
    const typeName = toTypeName(key);

    // Generate const array
    lines.push(`export const ${constName} = [`);
    for (const value of values) {
      lines.push(`  '${value}',`);
    }
    lines.push('] as const;');
    lines.push('');

    // Generate type from const
    lines.push(`export type ${typeName} = typeof ${constName}[number];`);
    lines.push('');
  }

  return lines.join('\n');
}

async function main() {
  // Check for --input argument
  let inputPath: string | undefined;
  const inputIndex = process.argv.indexOf('--input');
  if (inputIndex !== -1 && process.argv[inputIndex + 1]) {
    inputPath = process.argv[inputIndex + 1];
  }

  let jsonContent: string;

  if (inputPath) {
    // Read from file
    if (!fs.existsSync(inputPath)) {
      console.error(`Error: Input file not found: ${inputPath}`);
      process.exit(1);
    }
    jsonContent = fs.readFileSync(inputPath, 'utf-8');
    console.log(`Reading schema from: ${inputPath}`);
  } else {
    // Read from stdin
    console.log('Reading schema from stdin...');
    jsonContent = fs.readFileSync(0, 'utf-8');
  }

  let enums: SchemaEnums;
  try {
    enums = JSON.parse(jsonContent);
  } catch (e) {
    console.error('Error: Invalid JSON input');
    console.error(e);
    process.exit(1);
  }

  const enumCount = Object.keys(enums).length;
  console.log(`Found ${enumCount} validation constants`);

  // Generate TypeScript
  const typescript = generateTypeScript(enums);

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    console.log(`Created directory: ${OUTPUT_DIR}`);
  }

  // Write output
  fs.writeFileSync(OUTPUT_FILE, typescript);
  console.log(`Generated: ${OUTPUT_FILE}`);

  // Print summary
  for (const key of Object.keys(enums).sort()) {
    console.log(`  - ${toConstantName(key)}: ${enums[key].length} values`);
  }
}

main().catch(console.error);
