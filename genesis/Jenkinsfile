/**
 * Genesis Pipeline (elohim-genesis)
 *
 * Seeds content from genesis/data/lamad to Holochain via doorway.
 * Triggered by orchestrator after successful holochain/edge/app builds.
 *
 * Pipeline: checkout â†’ resolve hosts â†’ verify health â†’ seed
 *
 * Auto-detects target environment from branch:
 *   - dev, feat-*, claude-* â†’ alpha.elohim.host (doorway-dev)
 *   - staging*              â†’ staging.elohim.host (doorway-dev)
 *   - main                  â†’ elohim.host (doorway)
 *
 * Parameters:
 *   - TARGET_HOST: Override auto-detected host (optional)
 *   - SEED_DATA: Enable/disable seeding (default: true)
 *   - SEED_IDS: Comma-separated list of specific IDs to seed (optional)
 */

def resolveDoorwayHost(String targetHost, String explicitDoorway) {
    if (explicitDoorway) {
        return explicitDoorway
    }
    // Auto-detect doorway host from target host
    // Architecture: dev doorway serves both alpha AND staging apps
    // Only production app uses the production doorway
    if (targetHost.contains('alpha.elohim.host') || targetHost.contains('staging.elohim.host')) {
        return 'https://doorway-dev.elohim.host'
    } else if (targetHost.contains('elohim.host') && !targetHost.contains('doorway')) {
        return 'https://doorway.elohim.host'
    } else {
        // For custom hosts, try doorway subdomain
        return targetHost.replaceFirst('://', '://doorway.')
    }
}

def resolveInternalDoorwayUrl(String doorwayHost) {
    // Map external DNS to internal Kubernetes DNS
    // Note: Only dev and prod edgenodes exist (no staging edgenode)
    if (doorwayHost.contains('doorway-dev.elohim.host')) {
        return 'elohim-edgenode-dev.ethosengine.svc.cluster.local:8080'
    } else if (doorwayHost.contains('doorway.elohim.host') && !doorwayHost.contains('doorway-dev')) {
        return 'elohim-edgenode-prod.ethosengine.svc.cluster.local:8080'
    }
    // For custom hosts, try using external URL
    return doorwayHost.replace('https://', '').replace('http://', '')
}

pipeline {
    agent {
        kubernetes {
            cloud 'kubernetes'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  serviceAccount: jenkins-deployer
  nodeSelector:
    node-type: edge
  containers:
  - name: builder
    image: harbor.ethosengine.com/ethosengine/ci-builder:latest
    command:
    - cat
    tty: true
    resources:
      requests:
        ephemeral-storage: "2Gi"
        memory: "2Gi"
      limits:
        ephemeral-storage: "5Gi"
        memory: "4Gi"
'''
        }
    }

    parameters {
        string(
            name: 'TARGET_HOST',
            defaultValue: '',
            description: 'Target host URL (auto-detected from branch if empty)'
        )
        booleanParam(
            name: 'SEED_DATA',
            defaultValue: true,
            description: 'Seed the database with content from genesis/data/lamad'
        )
        string(
            name: 'SEED_IDS',
            defaultValue: '',
            description: 'Specific content IDs to seed (comma-separated). Empty = all content'
        )
    }

    environment {
        NO_COLOR = '1'
    }

    options {
        skipDefaultCheckout(true)
        timeout(time: 120, unit: 'MINUTES')  // 2 hours for large seed datasets (3500+ items + paths)
        buildDiscarder(logRotator(numToKeepStr: '20'))
    }

    // No triggers - orchestrator handles triggering genesis after all builds complete
    // triggers { }

    stages {
        stage('Check Trigger') {
            steps {
                script {
                    def validTrigger = currentBuild.getBuildCauses().any { cause ->
                        cause._class.contains('UpstreamCause') || cause._class.contains('UserIdCause')
                    }
                    if (!validTrigger) {
                        echo "â­ï¸ PIPELINE SKIPPED - Use orchestrator or manual trigger"
                        currentBuild.result = 'NOT_BUILT'
                        currentBuild.displayName = "#${env.BUILD_NUMBER} SKIPPED"
                        env.PIPELINE_SKIPPED = 'true'
                    } else {
                        echo "âœ… Valid trigger: ${currentBuild.getBuildCauses()*.shortDescription.join(', ')}"
                    }
                }
            }
        }

        stage('Checkout') {
            when { expression { env.PIPELINE_SKIPPED != 'true' } }
            steps {
                container('builder') {
                    script {
                        sh 'git config --global --add safe.directory "*"'

                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${env.BRANCH_NAME ?: 'dev'}"]],
                            extensions: [
                                [$class: 'CloneOption', shallow: true, noTags: true, depth: 1],
                                [$class: 'CleanBeforeCheckout']
                            ],
                            userRemoteConfigs: [[
                                url: 'https://github.com/ethosengine/elohim.git',
                                credentialsId: 'ee-bot-pat'
                            ]]
                        ])

                        echo """
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸŒ± GENESIS PIPELINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Branch: ${env.BRANCH_NAME ?: 'dev'}
Seed Data: ${params.SEED_DATA}
Seed IDs: ${params.SEED_IDS ?: '(all)'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """
                    }
                }
            }
        }

        stage('Resolve Hosts') {
            when { expression { env.PIPELINE_SKIPPED != 'true' } }
            steps {
                container('builder') {
                    script {
                        // Auto-detect target host based on branch if not specified
                        def targetHost = params.TARGET_HOST
                        if (!targetHost) {
                            if (env.BRANCH_NAME == 'main') {
                                targetHost = 'https://elohim.host'
                            } else if (env.BRANCH_NAME == 'staging' || env.BRANCH_NAME ==~ /staging-.+/) {
                                targetHost = 'https://staging.elohim.host'
                            } else {
                                // dev, feat-*, claude/* branches â†’ alpha
                                targetHost = 'https://alpha.elohim.host'
                            }
                            echo "Auto-detected target host from branch '${env.BRANCH_NAME}': ${targetHost}"
                        }

                        env.TARGET_HOST = targetHost
                        def doorwayHost = resolveDoorwayHost(targetHost, '')
                        def internalDoorway = resolveInternalDoorwayUrl(doorwayHost)

                        env.RESOLVED_DOORWAY_HOST = doorwayHost
                        env.INTERNAL_DOORWAY_URL = internalDoorway

                        echo "âœ… Target host: ${targetHost}"
                        echo "âœ… Doorway API (external): ${doorwayHost}"
                        echo "âœ… Doorway API (internal): ${internalDoorway}"
                    }
                }
            }
        }

        stage('Install Seeder') {
            when { allOf { expression { env.PIPELINE_SKIPPED != 'true' }; expression { params.SEED_DATA } } }
            steps {
                container('builder') {
                    dir('genesis/seeder') {
                        sh '''
                            echo "Installing seeder dependencies..."
                            npm ci --prefer-offline
                            echo "âœ… Seeder ready"
                        '''
                    }
                }
            }
        }


        stage('Verify Target Health') {
            when { expression { env.PIPELINE_SKIPPED != 'true' } }
            steps {
                container('builder') {
                    script {
                        // Ensure jq is available for JSON parsing
                        sh '''
                            command -v jq >/dev/null 2>&1 || {
                                echo "Installing jq..."
                                apt-get update -qq && apt-get install -y -qq jq 2>/dev/null || apk add --no-cache jq
                            }
                        '''

                        def targetHost = env.TARGET_HOST
                        def doorwayHost = env.RESOLVED_DOORWAY_HOST
                        def internalDoorway = env.INTERNAL_DOORWAY_URL

                        echo "Verifying target site: ${targetHost}"
                        sh """
                            timeout 120s bash -c 'until curl -sf -o /dev/null "${targetHost}"; do
                                echo "Waiting for target site..."
                                sleep 5
                            done'
                            echo "âœ… Target site responding: ${targetHost}"
                        """

                        // Use /status endpoint for comprehensive preflight checks
                        // This includes: conductor connectivity, storage health, cell discovery
                        echo "Verifying Doorway readiness (internal): ${internalDoorway}"
                        sh """#!/bin/bash
                            set -euo pipefail

                            MAX_ATTEMPTS=30
                            ATTEMPT=1
                            DOORWAY_READY=false
                            DOORWAY_BASE_URL=""

                            # First, wait for doorway to be reachable
                            while [ \$ATTEMPT -le \$MAX_ATTEMPTS ]; do
                                # Try internal DNS first
                                if curl -sf -o /dev/null "http://${internalDoorway}/health" 2>/dev/null; then
                                    DOORWAY_BASE_URL="http://${internalDoorway}"
                                    echo "âœ… Doorway responding (via internal DNS)"
                                    break
                                fi
                                # Fall back to external DNS
                                if curl -sf -o /dev/null "${doorwayHost}/health" 2>/dev/null; then
                                    DOORWAY_BASE_URL="${doorwayHost}"
                                    echo "âœ… Doorway responding (via external DNS)"
                                    break
                                fi
                                echo "Waiting for Doorway... (attempt \$ATTEMPT/\$MAX_ATTEMPTS)"
                                sleep 5
                                ATTEMPT=\$((ATTEMPT + 1))
                            done

                            if [ -z "\$DOORWAY_BASE_URL" ]; then
                                echo "âŒ Doorway not responding after \$MAX_ATTEMPTS attempts"
                                exit 1
                            fi

                            # Now use /status for comprehensive preflight checks
                            echo ""
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo "ğŸ” PREFLIGHT CHECKS"
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                            PREFLIGHT_ATTEMPTS=0
                            PREFLIGHT_MAX=24  # 2 minutes with 5s intervals
                            CONDUCTOR_READY=false

                            while [ \$PREFLIGHT_ATTEMPTS -lt \$PREFLIGHT_MAX ]; do
                                STATUS_JSON=\$(curl -sf "\$DOORWAY_BASE_URL/status" 2>/dev/null || echo '{}')

                                # Parse status response
                                CONDUCTOR_CONNECTED=\$(echo "\$STATUS_JSON" | jq -r '.conductor.connected // false')
                                CONDUCTOR_WORKERS=\$(echo "\$STATUS_JSON" | jq -r '.conductor.connected_workers // 0')
                                STORAGE_HEALTHY=\$(echo "\$STATUS_JSON" | jq -r '.storage.healthy // false')
                                IMPORT_ENABLED=\$(echo "\$STATUS_JSON" | jq -r '.storage.import_enabled // false')
                                CELL_DISCOVERED=\$(echo "\$STATUS_JSON" | jq -r '.diagnostics.cell_discovered // false')
                                READY_FOR_SEEDING=\$(echo "\$STATUS_JSON" | jq -r '.diagnostics.ready_for_seeding // false')

                                echo "  Conductor: connected=\$CONDUCTOR_CONNECTED workers=\$CONDUCTOR_WORKERS"
                                echo "  Storage: healthy=\$STORAGE_HEALTHY import=\$IMPORT_ENABLED"
                                echo "  Cell discovered: \$CELL_DISCOVERED"
                                echo "  Ready for seeding: \$READY_FOR_SEEDING"

                                # Check recommendations for any blockers
                                RECOMMENDATIONS=\$(echo "\$STATUS_JSON" | jq -r '.diagnostics.recommendations // []')
                                if [ "\$RECOMMENDATIONS" != "[]" ] && [ "\$RECOMMENDATIONS" != "null" ]; then
                                    echo "  Recommendations:"
                                    echo "\$RECOMMENDATIONS" | jq -r '.[] | "    âš ï¸  " + .'
                                fi

                                # Check if ready
                                if [ "\$CONDUCTOR_CONNECTED" = "true" ] && [ "\$STORAGE_HEALTHY" = "true" ]; then
                                    # With lazy cell discovery, we don't need cell_discovered=true at preflight
                                    # The seeder will trigger lazy discovery on first import
                                    echo ""
                                    echo "âœ… Doorway ready for seeding"
                                    echo "   Note: cell_id will be discovered lazily on first import if not already cached"
                                    CONDUCTOR_READY=true
                                    break
                                fi

                                PREFLIGHT_ATTEMPTS=\$((PREFLIGHT_ATTEMPTS + 1))
                                if [ \$PREFLIGHT_ATTEMPTS -lt \$PREFLIGHT_MAX ]; then
                                    echo "  â³ Waiting for conductor/storage... (\$PREFLIGHT_ATTEMPTS/\$PREFLIGHT_MAX)"
                                    sleep 5
                                fi
                            done

                            if [ "\$CONDUCTOR_READY" != "true" ]; then
                                echo ""
                                echo "âŒ PREFLIGHT FAILED: Doorway not ready for seeding"
                                echo "   Conductor connected: \$CONDUCTOR_CONNECTED"
                                echo "   Storage healthy: \$STORAGE_HEALTHY"
                                echo ""
                                echo "Check doorway and elohim-storage logs for issues."
                                exit 1
                            fi

                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                        """
                    }
                }
            }
        }

        stage('Seed Database') {
            when { allOf { expression { env.PIPELINE_SKIPPED != 'true' }; expression { params.SEED_DATA } } }
            steps {
                container('builder') {
                    script {
                        def internalDoorway = env.INTERNAL_DOORWAY_URL
                        def seedIds = params.SEED_IDS

                        dir('genesis/seeder') {
                            sh """#!/bin/bash
                                set -euo pipefail

                                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                                echo "ğŸŒ± SEEDING DATABASE"
                                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                                echo "Target: ${internalDoorway}"
                                echo "IDs: ${seedIds ?: '(all content)'}"
                                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                                echo ""

                                SEED_CMD="npx tsx src/seed.ts"
                                if [ -n "${seedIds}" ]; then
                                    SEED_CMD="\$SEED_CMD --ids ${seedIds}"
                                fi

                                # CI uses doorway HTTP import: blob upload + queue import
                                # - DOORWAY_URL: HTTP endpoint for blob uploads and queue_import
                                # - DOORWAY_API_KEY: Authentication for admin endpoints
                                # - HOLOCHAIN_ADMIN_URL: WebSocket for pre/post-flight verification
                                # - SEED_POLL_TIMEOUT: 90 min for full seeding (content + paths)
                                # Note: Chunk size/delay now controlled by elohim-storage env vars
                                DOORWAY_URL="http://${internalDoorway}" \
                                DOORWAY_API_KEY="dev-elohim-auth-2024" \
                                HOLOCHAIN_ADMIN_URL="ws://${internalDoorway}?apiKey=dev-elohim-auth-2024" \
                                SEED_POLL_TIMEOUT=5400000 \
                                    \$SEED_CMD

                                echo ""
                                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                                echo "âœ… DATABASE SEEDED SUCCESSFULLY"
                                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            """
                        }
                    }
                }
            }
        }

    }

    post {
        success {
            script {
                echo """
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ… GENESIS PIPELINE COMPLETE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Target: ${env.TARGET_HOST}
Seeded: ${params.SEED_DATA}
IDs: ${params.SEED_IDS ?: '(all)'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
            }
        }
        failure {
            script {
                echo """
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âŒ GENESIS PIPELINE FAILED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Target: ${env.TARGET_HOST}
Seeded: ${params.SEED_DATA}
IDs: ${params.SEED_IDS ?: '(all)'}

Check the logs for details.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
            }
        }
    }
}
