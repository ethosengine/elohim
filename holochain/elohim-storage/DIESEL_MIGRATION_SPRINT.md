# Diesel Migration Sprint - Handoff Document

## Summary

Migrate `elohim-storage` from raw rusqlite SQL to Diesel ORM for compile-time verified queries, type-safe schema definitions, and long-term maintainability.

## Why Diesel over SeaORM

| Aspect | Diesel | SeaORM |
|--------|--------|--------|
| **Query verification** | Compile-time SQL checking | Runtime errors |
| **Maturity** | 8+ years, battle-tested | Newer, less proven |
| **AI-assisted dev** | Compiler catches mistakes immediately | Errors surface at runtime |
| **Performance** | Zero-cost abstractions, no runtime overhead | Some runtime reflection |
| **Schema source of truth** | `schema.rs` generated from DB | Entity macros |
| **Sync/Async** | Sync by default (diesel-async available) | Async-first |

**Key advantage for vibecoding**: Diesel's compile-time verification means the Rust compiler tells you immediately if a query is wrong. No waiting until runtime to discover typos or schema mismatches.

## Background

### Current State

The `elohim-storage` service uses raw `rusqlite` with:
- Manual `from_row()` implementations
- Hand-written SQL strings
- No compile-time validation
- Verbose error handling boilerplate

### Diesel Benefits

```rust
// BEFORE: rusqlite (runtime errors, verbose)
pub fn get_content(conn: &Connection, id: &str) -> Result<Option<ContentRow>, StorageError> {
    let mut stmt = conn
        .prepare("SELECT * FROM content WHERE id = ?")  // Typo here? Runtime error!
        .map_err(|e| StorageError::Internal(format!("Prepare failed: {}", e)))?;
    // ... 15 more lines of boilerplate
}

// AFTER: Diesel (compile-time verified, concise)
pub fn get_content(conn: &mut SqliteConnection, content_id: &str) -> QueryResult<Option<Content>> {
    content::table
        .find(content_id)  // Typo here? Compile error!
        .first(conn)
        .optional()
}
```

## Architecture

### File Structure

```
holochain/elohim-storage/
├── Cargo.toml              # Add diesel dependency
├── diesel.toml             # Diesel CLI configuration
├── migrations/             # SQL migration files
│   └── 2026-01-08-000000_initial/
│       ├── up.sql          # Create tables
│       └── down.sql        # Drop tables
└── src/
    ├── db/
    │   ├── mod.rs          # Database module
    │   ├── schema.rs       # AUTO-GENERATED by diesel CLI
    │   ├── models.rs       # Queryable/Insertable structs
    │   ├── content.rs      # Content CRUD operations
    │   └── paths.rs        # Path CRUD operations
    └── ...
```

### Schema Generation Flow

```
migrations/*.sql  →  diesel migration run  →  schema.rs (auto-generated)
                                                    ↓
                                            models.rs (your structs)
                                                    ↓
                                            Compile-time verified queries
```

## Implementation Tasks

### Phase 1: Dependencies & Setup

**1.1 Add Diesel to Cargo.toml**

```toml
# Replace rusqlite with diesel
diesel = { version = "2.2", features = ["sqlite", "r2d2"] }

# Keep rusqlite for now during transition (same version diesel uses internally)
# rusqlite = { version = "0.37", features = ["bundled", "serde_json"] }
```

**1.2 Create diesel.toml**

```toml
[print_schema]
file = "src/db/schema.rs"
custom_type_derives = ["diesel::query_builder::QueryId"]

[migrations_directory]
dir = "migrations"
```

**1.3 Install Diesel CLI** (development only)

```bash
cargo install diesel_cli --no-default-features --features sqlite
```

### Phase 2: Migrations

**2.1 Create initial migration**

```bash
cd holochain/elohim-storage
diesel migration generate initial
```

**2.2 Write up.sql** (from existing schema.rs)

```sql
-- migrations/2026-01-08-000000_initial/up.sql

-- Schema version tracking
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER NOT NULL
);
INSERT INTO schema_version (version) VALUES (1);

-- Content table
CREATE TABLE content (
    id TEXT PRIMARY KEY NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    content_type TEXT NOT NULL DEFAULT 'concept',
    content_format TEXT NOT NULL DEFAULT 'markdown',
    blob_hash TEXT,
    blob_cid TEXT,
    content_size_bytes INTEGER,
    metadata_json TEXT,
    reach TEXT NOT NULL DEFAULT 'public',
    validation_status TEXT NOT NULL DEFAULT 'valid',
    created_by TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE content_tags (
    content_id TEXT NOT NULL REFERENCES content(id) ON DELETE CASCADE,
    tag TEXT NOT NULL,
    PRIMARY KEY (content_id, tag)
);

-- Paths table
CREATE TABLE paths (
    id TEXT PRIMARY KEY NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    path_type TEXT NOT NULL DEFAULT 'guided',
    difficulty TEXT DEFAULT 'beginner',
    estimated_duration TEXT,
    thumbnail_url TEXT,
    thumbnail_alt TEXT,
    metadata_json TEXT,
    visibility TEXT NOT NULL DEFAULT 'public',
    created_by TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE path_tags (
    path_id TEXT NOT NULL REFERENCES paths(id) ON DELETE CASCADE,
    tag TEXT NOT NULL,
    PRIMARY KEY (path_id, tag)
);

-- Chapters
CREATE TABLE chapters (
    id TEXT PRIMARY KEY NOT NULL,
    path_id TEXT NOT NULL REFERENCES paths(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    order_index INTEGER NOT NULL DEFAULT 0,
    estimated_duration TEXT
);

-- Steps
CREATE TABLE steps (
    id TEXT PRIMARY KEY NOT NULL,
    path_id TEXT NOT NULL REFERENCES paths(id) ON DELETE CASCADE,
    chapter_id TEXT REFERENCES chapters(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    description TEXT,
    step_type TEXT NOT NULL DEFAULT 'learn',
    resource_id TEXT,
    resource_type TEXT DEFAULT 'content',
    order_index INTEGER NOT NULL DEFAULT 0,
    estimated_duration TEXT,
    metadata_json TEXT
);

-- Indexes
CREATE INDEX idx_content_type ON content(content_type);
CREATE INDEX idx_content_format ON content(content_format);
CREATE INDEX idx_content_reach ON content(reach);
CREATE INDEX idx_content_tags_tag ON content_tags(tag);
CREATE INDEX idx_paths_visibility ON paths(visibility);
CREATE INDEX idx_path_tags_tag ON path_tags(tag);
CREATE INDEX idx_steps_path_id ON steps(path_id);
CREATE INDEX idx_steps_chapter_id ON steps(chapter_id);
CREATE INDEX idx_chapters_path_id ON chapters(path_id);
```

**2.3 Write down.sql**

```sql
-- migrations/2026-01-08-000000_initial/down.sql
DROP TABLE IF EXISTS steps;
DROP TABLE IF EXISTS chapters;
DROP TABLE IF EXISTS path_tags;
DROP TABLE IF EXISTS paths;
DROP TABLE IF EXISTS content_tags;
DROP TABLE IF EXISTS content;
DROP TABLE IF EXISTS schema_version;
```

**2.4 Run migration to generate schema.rs**

```bash
diesel migration run --database-url /tmp/elohim-storage/content.db
```

This auto-generates `src/db/schema.rs`:

```rust
// @generated automatically by Diesel CLI.

diesel::table! {
    content (id) {
        id -> Text,
        title -> Text,
        description -> Nullable<Text>,
        content_type -> Text,
        content_format -> Text,
        blob_hash -> Nullable<Text>,
        blob_cid -> Nullable<Text>,
        content_size_bytes -> Nullable<BigInt>,
        metadata_json -> Nullable<Text>,
        reach -> Text,
        validation_status -> Text,
        created_by -> Nullable<Text>,
        created_at -> Text,
        updated_at -> Text,
    }
}

diesel::table! {
    content_tags (content_id, tag) {
        content_id -> Text,
        tag -> Text,
    }
}

// ... more tables
```

### Phase 3: Model Definitions

**3.1 Create src/db/models.rs**

```rust
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

use super::schema::*;

// ============================================================================
// Content Models
// ============================================================================

/// Content row - for SELECT queries
#[derive(Debug, Clone, Queryable, Selectable, Serialize, Deserialize)]
#[diesel(table_name = content)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct Content {
    pub id: String,
    pub title: String,
    pub description: Option<String>,
    pub content_type: String,
    pub content_format: String,
    pub blob_hash: Option<String>,
    pub blob_cid: Option<String>,
    pub content_size_bytes: Option<i64>,
    pub metadata_json: Option<String>,
    pub reach: String,
    pub validation_status: String,
    pub created_by: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

/// New content - for INSERT queries
#[derive(Debug, Clone, Insertable, Deserialize)]
#[diesel(table_name = content)]
pub struct NewContent<'a> {
    pub id: &'a str,
    pub title: &'a str,
    pub description: Option<&'a str>,
    pub content_type: &'a str,
    pub content_format: &'a str,
    pub blob_hash: Option<&'a str>,
    pub blob_cid: Option<&'a str>,
    pub content_size_bytes: Option<i64>,
    pub metadata_json: Option<&'a str>,
    pub reach: &'a str,
    pub created_by: Option<&'a str>,
}

/// Content tag row
#[derive(Debug, Clone, Queryable, Selectable, Insertable, Serialize)]
#[diesel(table_name = content_tags)]
pub struct ContentTag {
    pub content_id: String,
    pub tag: String,
}

// ============================================================================
// Path Models
// ============================================================================

/// Path row - for SELECT queries
#[derive(Debug, Clone, Queryable, Selectable, Serialize, Deserialize)]
#[diesel(table_name = paths)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct Path {
    pub id: String,
    pub title: String,
    pub description: Option<String>,
    pub path_type: String,
    pub difficulty: Option<String>,
    pub estimated_duration: Option<String>,
    pub thumbnail_url: Option<String>,
    pub thumbnail_alt: Option<String>,
    pub metadata_json: Option<String>,
    pub visibility: String,
    pub created_by: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

/// New path - for INSERT queries
#[derive(Debug, Clone, Insertable)]
#[diesel(table_name = paths)]
pub struct NewPath<'a> {
    pub id: &'a str,
    pub title: &'a str,
    pub description: Option<&'a str>,
    pub path_type: &'a str,
    pub difficulty: Option<&'a str>,
    pub estimated_duration: Option<&'a str>,
    pub thumbnail_url: Option<&'a str>,
    pub thumbnail_alt: Option<&'a str>,
    pub metadata_json: Option<&'a str>,
    pub visibility: &'a str,
    pub created_by: Option<&'a str>,
}

// ============================================================================
// Chapter Models
// ============================================================================

#[derive(Debug, Clone, Queryable, Selectable, Serialize, Deserialize)]
#[diesel(table_name = chapters)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct Chapter {
    pub id: String,
    pub path_id: String,
    pub title: String,
    pub description: Option<String>,
    pub order_index: i32,
    pub estimated_duration: Option<String>,
}

#[derive(Debug, Clone, Insertable)]
#[diesel(table_name = chapters)]
pub struct NewChapter<'a> {
    pub id: &'a str,
    pub path_id: &'a str,
    pub title: &'a str,
    pub description: Option<&'a str>,
    pub order_index: i32,
    pub estimated_duration: Option<&'a str>,
}

// ============================================================================
// Step Models
// ============================================================================

#[derive(Debug, Clone, Queryable, Selectable, Serialize, Deserialize)]
#[diesel(table_name = steps)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct Step {
    pub id: String,
    pub path_id: String,
    pub chapter_id: Option<String>,
    pub title: String,
    pub description: Option<String>,
    pub step_type: String,
    pub resource_id: Option<String>,
    pub resource_type: Option<String>,
    pub order_index: i32,
    pub estimated_duration: Option<String>,
    pub metadata_json: Option<String>,
}

#[derive(Debug, Clone, Insertable)]
#[diesel(table_name = steps)]
pub struct NewStep<'a> {
    pub id: &'a str,
    pub path_id: &'a str,
    pub chapter_id: Option<&'a str>,
    pub title: &'a str,
    pub description: Option<&'a str>,
    pub step_type: &'a str,
    pub resource_id: Option<&'a str>,
    pub resource_type: Option<&'a str>,
    pub order_index: i32,
    pub estimated_duration: Option<&'a str>,
    pub metadata_json: Option<&'a str>,
}
```

### Phase 4: CRUD Operations

**4.1 Content operations (src/db/content.rs)**

```rust
use diesel::prelude::*;
use super::models::{Content, NewContent, ContentTag};
use super::schema::{content, content_tags};

/// Get content by ID
pub fn get_content(conn: &mut SqliteConnection, content_id: &str) -> QueryResult<Option<Content>> {
    content::table
        .find(content_id)
        .first(conn)
        .optional()
}

/// Get content with tags
pub fn get_content_with_tags(
    conn: &mut SqliteConnection,
    content_id: &str,
) -> QueryResult<Option<(Content, Vec<String>)>> {
    let content_opt: Option<Content> = content::table
        .find(content_id)
        .first(conn)
        .optional()?;

    match content_opt {
        Some(c) => {
            let tags: Vec<String> = content_tags::table
                .filter(content_tags::content_id.eq(content_id))
                .select(content_tags::tag)
                .load(conn)?;
            Ok(Some((c, tags)))
        }
        None => Ok(None),
    }
}

/// List content with filters
pub fn list_content(
    conn: &mut SqliteConnection,
    content_type_filter: Option<&str>,
    content_format_filter: Option<&str>,
    search: Option<&str>,
    limit: i64,
    offset: i64,
) -> QueryResult<Vec<Content>> {
    let mut query = content::table.into_boxed();

    if let Some(ct) = content_type_filter {
        query = query.filter(content::content_type.eq(ct));
    }

    if let Some(cf) = content_format_filter {
        query = query.filter(content::content_format.eq(cf));
    }

    if let Some(s) = search {
        let pattern = format!("%{}%", s);
        query = query.filter(
            content::title.like(&pattern)
                .or(content::description.like(&pattern))
        );
    }

    query
        .order(content::created_at.desc())
        .limit(limit)
        .offset(offset)
        .load(conn)
}

/// Insert content
pub fn create_content(conn: &mut SqliteConnection, new: NewContent) -> QueryResult<Content> {
    diesel::insert_into(content::table)
        .values(&new)
        .returning(Content::as_returning())
        .get_result(conn)
}

/// Bulk insert content (for seeding)
pub fn bulk_insert_content(
    conn: &mut SqliteConnection,
    items: Vec<NewContent>,
) -> QueryResult<usize> {
    diesel::insert_or_ignore_into(content::table)
        .values(&items)
        .execute(conn)
}

/// Delete content
pub fn delete_content(conn: &mut SqliteConnection, content_id: &str) -> QueryResult<usize> {
    diesel::delete(content::table.find(content_id))
        .execute(conn)
}
```

**4.2 Path operations (src/db/paths.rs)**

```rust
use diesel::prelude::*;
use super::models::{Path, NewPath, Chapter, NewChapter, Step, NewStep};
use super::schema::{paths, chapters, steps, path_tags};

/// Get path by ID
pub fn get_path(conn: &mut SqliteConnection, path_id: &str) -> QueryResult<Option<Path>> {
    paths::table
        .find(path_id)
        .first(conn)
        .optional()
}

/// Get path with chapters and steps
pub fn get_path_with_steps(
    conn: &mut SqliteConnection,
    path_id: &str,
) -> QueryResult<Option<PathWithSteps>> {
    let path_opt: Option<Path> = paths::table
        .find(path_id)
        .first(conn)
        .optional()?;

    let path = match path_opt {
        Some(p) => p,
        None => return Ok(None),
    };

    // Load chapters ordered by order_index
    let path_chapters: Vec<Chapter> = chapters::table
        .filter(chapters::path_id.eq(path_id))
        .order(chapters::order_index.asc())
        .load(conn)?;

    // Load steps for each chapter
    let mut chapters_with_steps = Vec::new();
    for chapter in path_chapters {
        let chapter_steps: Vec<Step> = steps::table
            .filter(steps::chapter_id.eq(&chapter.id))
            .order(steps::order_index.asc())
            .load(conn)?;
        chapters_with_steps.push(ChapterWithSteps {
            chapter,
            steps: chapter_steps,
        });
    }

    // Load ungrouped steps (no chapter)
    let ungrouped: Vec<Step> = steps::table
        .filter(steps::path_id.eq(path_id))
        .filter(steps::chapter_id.is_null())
        .order(steps::order_index.asc())
        .load(conn)?;

    Ok(Some(PathWithSteps {
        path,
        chapters: chapters_with_steps,
        ungrouped_steps: ungrouped,
    }))
}

/// Path with nested chapters and steps
#[derive(Debug, Clone, Serialize)]
pub struct PathWithSteps {
    pub path: Path,
    pub chapters: Vec<ChapterWithSteps>,
    pub ungrouped_steps: Vec<Step>,
}

#[derive(Debug, Clone, Serialize)]
pub struct ChapterWithSteps {
    pub chapter: Chapter,
    pub steps: Vec<Step>,
}

/// List all paths
pub fn list_paths(
    conn: &mut SqliteConnection,
    limit: i64,
    offset: i64,
) -> QueryResult<Vec<Path>> {
    paths::table
        .order(paths::created_at.desc())
        .limit(limit)
        .offset(offset)
        .load(conn)
}

/// Create path with chapters and steps (transaction)
pub fn create_path_with_steps(
    conn: &mut SqliteConnection,
    new_path: NewPath,
    new_chapters: Vec<(NewChapter, Vec<NewStep>)>,
) -> QueryResult<Path> {
    conn.transaction(|conn| {
        // Insert path
        diesel::insert_into(paths::table)
            .values(&new_path)
            .execute(conn)?;

        // Insert chapters and their steps
        for (chapter, chapter_steps) in new_chapters {
            diesel::insert_into(chapters::table)
                .values(&chapter)
                .execute(conn)?;

            if !chapter_steps.is_empty() {
                diesel::insert_into(steps::table)
                    .values(&chapter_steps)
                    .execute(conn)?;
            }
        }

        // Return the created path
        paths::table.find(new_path.id).first(conn)
    })
}

/// Delete path (cascades to chapters and steps via FK)
pub fn delete_path(conn: &mut SqliteConnection, path_id: &str) -> QueryResult<usize> {
    diesel::delete(paths::table.find(path_id))
        .execute(conn)
}
```

### Phase 5: Connection Pool

**5.1 Add r2d2 connection pool**

```rust
// src/db/mod.rs
use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};
use std::time::Duration;

pub mod schema;
pub mod models;
pub mod content;
pub mod paths;

pub type DbPool = r2d2::Pool<ConnectionManager<SqliteConnection>>;

/// Initialize connection pool
pub fn init_pool(database_url: &str) -> Result<DbPool, r2d2::Error> {
    let manager = ConnectionManager::<SqliteConnection>::new(database_url);
    r2d2::Pool::builder()
        .max_size(10)
        .connection_timeout(Duration::from_secs(30))
        .build(manager)
}
```

### Phase 6: HTTP Handler Updates

**Example update for db.rs routes:**

```rust
// BEFORE
let conn = state.db.lock().unwrap();
let content = crate::db::content::get_content(&conn, &id)?;

// AFTER
let mut conn = state.pool.get().map_err(|e| ...)?;
let content = crate::db::content::get_content(&mut conn, &id)?;
```

## Migration Checklist

- [x] Add diesel to Cargo.toml
- [x] Create diesel.toml
- [x] Create migrations/initial/up.sql with **app_id scoping**
- [x] Create diesel_schema.rs (manually, will auto-generate after migration run)
- [x] Create models.rs with Queryable/Insertable structs (includes app_id)
- [x] Create context.rs with AppContext for multi-tenancy
- [x] Create content_diesel.rs - Diesel CRUD with app scoping
- [x] Create paths_diesel.rs - Diesel CRUD with app scoping
- [x] Add r2d2 connection pool
- [x] Update HTTP routes to extract app_id from path
- [ ] Update HTTP handlers to use Diesel (gradual migration)
- [ ] Update SDK storage client to use app_id in URLs
- [ ] Remove old rusqlite code
- [ ] Test seeding workflow

## Multi-Tenant App Scoping (New)

The migration now includes **app_id scoping** for multi-tenant isolation:

### Two Default Apps

| App ID | Purpose | Content Types |
|--------|---------|---------------|
| **lamad** | Learning content | Paths, concepts, quizzes, assessments |
| **elohim** | Shared infrastructure | Resources, sensemaking, attestations |

### Route Pattern

```
# New app-scoped routes
GET /db/{app_id}/content          # List content for app
GET /db/{app_id}/content/{id}     # Get content by ID
POST /db/{app_id}/content/bulk    # Bulk create for app

# Legacy routes (default to 'lamad')
GET /db/content                   # → AppContext("lamad")
GET /db/content/{id}              # → AppContext("lamad")
```

### AppContext

```rust
let ctx = AppContext::default_lamad();  // Learning content
let ctx = AppContext::default_elohim(); // Shared infrastructure
let ctx = AppContext::new("calendar");  // Custom app
```

### Query Pattern

All Diesel queries are scoped by app_id:

```rust
content::table
    .filter(content::app_id.eq(&ctx.app_id))  // ALWAYS filter by app
    .filter(content::id.eq(content_id))
    .first(conn)
```

## Testing

```bash
# Run migrations on test DB
DATABASE_URL=/tmp/test.db diesel migration run

# Run existing tests
cargo test

# Test seeding
DOORWAY_URL=http://localhost:8888 npm run seed:sample
```

## Compile-Time Guarantees

With Diesel, these errors are caught at **compile time**:

```rust
// Column name typo - COMPILE ERROR
content::table.filter(content::titlee.eq("foo"))
//                            ^^^^^^ no field `titlee`

// Wrong type - COMPILE ERROR
content::table.filter(content::content_size_bytes.eq("string"))
//                                                    ^^^^^^ expected i64

// Missing required field - COMPILE ERROR
diesel::insert_into(content::table)
    .values(NewContent { id: "x", title: "y" /* missing fields */ })
```

## Files to Modify

| File | Action |
|------|--------|
| `Cargo.toml` | Add diesel, remove direct rusqlite |
| `diesel.toml` | New - CLI config |
| `migrations/*/up.sql` | New - SQL migrations |
| `src/db/schema.rs` | Auto-generated |
| `src/db/models.rs` | New - model structs |
| `src/db/content.rs` | Rewrite with Diesel |
| `src/db/paths.rs` | Rewrite with Diesel |
| `src/db/mod.rs` | Add pool, exports |
| `src/routes/db.rs` | Use pool instead of mutex |
| `src/main.rs` | Initialize pool |

## References

- [Diesel Getting Started](https://diesel.rs/guides/getting-started)
- [Diesel Schema Generation](https://diesel.rs/guides/schema-in-depth)
- [Diesel CRUD Operations](https://diesel.rs/guides/all-about-inserts)
- [Diesel Associations](https://diesel.rs/guides/relations)

---

**Author**: Claude Code
**Created**: 2026-01-08
**Status**: Ready for implementation
