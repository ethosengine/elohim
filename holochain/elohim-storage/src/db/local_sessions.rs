//! Local sessions CRUD operations using Diesel
//!
//! Manages sessions for Tauri native handoff. Unlike other tables, local_sessions
//! is NOT app-scoped - it stores the user's identity across all apps.
//!
//! Sessions are created after OAuth flow with doorway and enable offline access.

use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::diesel_schema::local_sessions;
use super::models::{LocalSession, NewLocalSession, current_timestamp};
use crate::error::StorageError;

// ============================================================================
// Input Types
// ============================================================================

/// Input for creating a local session (from native handoff)
#[derive(Debug, Clone, Deserialize)]
pub struct CreateLocalSessionInput {
    /// Session ID (optional, will be generated if not provided)
    #[serde(default)]
    pub id: Option<String>,
    /// Holochain Human ID from doorway
    pub human_id: String,
    /// Local agent public key (generated by Tauri)
    pub agent_pub_key: String,
    /// Doorway URL that authenticated this session
    pub doorway_url: String,
    /// Doorway ID (optional)
    #[serde(default)]
    pub doorway_id: Option<String>,
    /// User identifier (email/username)
    pub identifier: String,
    /// Display name (optional)
    #[serde(default)]
    pub display_name: Option<String>,
    /// Profile image blob hash (optional)
    #[serde(default)]
    pub profile_image_hash: Option<String>,
    /// Bootstrap URL for P2P discovery (optional)
    #[serde(default)]
    pub bootstrap_url: Option<String>,
}

/// Response for session operations
#[derive(Debug, Clone, Serialize)]
pub struct SessionResponse {
    pub session: LocalSession,
}

// ============================================================================
// Read Operations
// ============================================================================

/// Get the currently active session (there should only be one)
pub fn get_active_session(
    conn: &mut SqliteConnection,
) -> Result<Option<LocalSession>, StorageError> {
    local_sessions::table
        .filter(local_sessions::is_active.eq(1))
        .order(local_sessions::created_at.desc())
        .first(conn)
        .optional()
        .map_err(|e| StorageError::Internal(format!("Query failed: {}", e)))
}

/// Get session by ID
pub fn get_session_by_id(
    conn: &mut SqliteConnection,
    id: &str,
) -> Result<Option<LocalSession>, StorageError> {
    local_sessions::table
        .filter(local_sessions::id.eq(id))
        .first(conn)
        .optional()
        .map_err(|e| StorageError::Internal(format!("Query failed: {}", e)))
}

/// Get session by human ID and agent public key
pub fn get_session_by_identity(
    conn: &mut SqliteConnection,
    human_id: &str,
    agent_pub_key: &str,
) -> Result<Option<LocalSession>, StorageError> {
    local_sessions::table
        .filter(local_sessions::human_id.eq(human_id))
        .filter(local_sessions::agent_pub_key.eq(agent_pub_key))
        .first(conn)
        .optional()
        .map_err(|e| StorageError::Internal(format!("Query failed: {}", e)))
}

/// List all sessions (including inactive)
pub fn list_all_sessions(
    conn: &mut SqliteConnection,
) -> Result<Vec<LocalSession>, StorageError> {
    local_sessions::table
        .order(local_sessions::created_at.desc())
        .load(conn)
        .map_err(|e| StorageError::Internal(format!("Query failed: {}", e)))
}

/// Check if any session exists
pub fn has_any_session(
    conn: &mut SqliteConnection,
) -> Result<bool, StorageError> {
    let count: i64 = local_sessions::table
        .count()
        .get_result(conn)
        .map_err(|e| StorageError::Internal(format!("Count failed: {}", e)))?;
    Ok(count > 0)
}

// ============================================================================
// Write Operations
// ============================================================================

/// Create a new local session
/// Automatically deactivates any existing active sessions
pub fn create_session(
    conn: &mut SqliteConnection,
    input: CreateLocalSessionInput,
) -> Result<LocalSession, StorageError> {
    // First, deactivate any existing active sessions
    deactivate_all_sessions(conn)?;

    let id = input.id.unwrap_or_else(|| Uuid::new_v4().to_string());

    let new_session = NewLocalSession {
        id: &id,
        human_id: &input.human_id,
        agent_pub_key: &input.agent_pub_key,
        doorway_url: &input.doorway_url,
        doorway_id: input.doorway_id.as_deref(),
        identifier: &input.identifier,
        display_name: input.display_name.as_deref(),
        profile_image_hash: input.profile_image_hash.as_deref(),
        bootstrap_url: input.bootstrap_url.as_deref(),
    };

    diesel::insert_into(local_sessions::table)
        .values(&new_session)
        .execute(conn)
        .map_err(|e| StorageError::Internal(format!("Insert failed: {}", e)))?;

    get_session_by_id(conn, &id)?
        .ok_or_else(|| StorageError::Internal("Failed to retrieve created session".into()))
}

/// Activate an existing session (and deactivate others)
pub fn activate_session(
    conn: &mut SqliteConnection,
    id: &str,
) -> Result<LocalSession, StorageError> {
    // First, deactivate all sessions
    deactivate_all_sessions(conn)?;

    // Then activate the specified one
    diesel::update(
        local_sessions::table.filter(local_sessions::id.eq(id))
    )
    .set((
        local_sessions::is_active.eq(1),
        local_sessions::updated_at.eq(current_timestamp()),
    ))
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Update failed: {}", e)))?;

    get_session_by_id(conn, id)?
        .ok_or_else(|| StorageError::NotFound(format!("Session {} not found", id)))
}

/// Deactivate a specific session
pub fn deactivate_session(
    conn: &mut SqliteConnection,
    id: &str,
) -> Result<bool, StorageError> {
    let updated = diesel::update(
        local_sessions::table.filter(local_sessions::id.eq(id))
    )
    .set((
        local_sessions::is_active.eq(0),
        local_sessions::updated_at.eq(current_timestamp()),
    ))
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Update failed: {}", e)))?;

    Ok(updated > 0)
}

/// Deactivate all sessions
pub fn deactivate_all_sessions(
    conn: &mut SqliteConnection,
) -> Result<u64, StorageError> {
    let updated = diesel::update(
        local_sessions::table.filter(local_sessions::is_active.eq(1))
    )
    .set((
        local_sessions::is_active.eq(0),
        local_sessions::updated_at.eq(current_timestamp()),
    ))
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Update failed: {}", e)))?;

    Ok(updated as u64)
}

/// Update last synced timestamp
pub fn update_last_synced(
    conn: &mut SqliteConnection,
    id: &str,
) -> Result<LocalSession, StorageError> {
    diesel::update(
        local_sessions::table.filter(local_sessions::id.eq(id))
    )
    .set((
        local_sessions::last_synced_at.eq(current_timestamp()),
        local_sessions::updated_at.eq(current_timestamp()),
    ))
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Update failed: {}", e)))?;

    get_session_by_id(conn, id)?
        .ok_or_else(|| StorageError::NotFound(format!("Session {} not found", id)))
}

/// Update profile info (display name, image)
pub fn update_profile(
    conn: &mut SqliteConnection,
    id: &str,
    display_name: Option<&str>,
    profile_image_hash: Option<&str>,
) -> Result<LocalSession, StorageError> {
    diesel::update(
        local_sessions::table.filter(local_sessions::id.eq(id))
    )
    .set((
        local_sessions::display_name.eq(display_name),
        local_sessions::profile_image_hash.eq(profile_image_hash),
        local_sessions::updated_at.eq(current_timestamp()),
    ))
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Update failed: {}", e)))?;

    get_session_by_id(conn, id)?
        .ok_or_else(|| StorageError::NotFound(format!("Session {} not found", id)))
}

/// Delete a session by ID
pub fn delete_session(
    conn: &mut SqliteConnection,
    id: &str,
) -> Result<bool, StorageError> {
    let deleted = diesel::delete(
        local_sessions::table.filter(local_sessions::id.eq(id))
    )
    .execute(conn)
    .map_err(|e| StorageError::Internal(format!("Delete failed: {}", e)))?;

    Ok(deleted > 0)
}

/// Delete all sessions (for logout/reset)
pub fn delete_all_sessions(
    conn: &mut SqliteConnection,
) -> Result<u64, StorageError> {
    let deleted = diesel::delete(local_sessions::table)
        .execute(conn)
        .map_err(|e| StorageError::Internal(format!("Delete failed: {}", e)))?;

    Ok(deleted as u64)
}

// ============================================================================
// Stats
// ============================================================================

/// Get session count
pub fn session_count(
    conn: &mut SqliteConnection,
) -> Result<i64, StorageError> {
    local_sessions::table
        .count()
        .get_result(conn)
        .map_err(|e| StorageError::Internal(format!("Count query failed: {}", e)))
}

#[cfg(test)]
mod tests {
    use super::*;
    use diesel::connection::SimpleConnection;

    fn setup_test_db() -> SqliteConnection {
        let mut conn = SqliteConnection::establish(":memory:")
            .expect("Failed to create in-memory database");

        // Create the table for testing
        conn.batch_execute(
            r#"
            CREATE TABLE local_sessions (
                id TEXT PRIMARY KEY NOT NULL,
                human_id TEXT NOT NULL,
                agent_pub_key TEXT NOT NULL,
                doorway_url TEXT NOT NULL,
                doorway_id TEXT,
                identifier TEXT NOT NULL,
                display_name TEXT,
                profile_image_hash TEXT,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                updated_at TEXT NOT NULL DEFAULT (datetime('now')),
                last_synced_at TEXT,
                bootstrap_url TEXT,
                UNIQUE(human_id, agent_pub_key)
            );
            "#,
        ).expect("Failed to create test table");

        conn
    }

    #[test]
    fn test_create_and_get_session() {
        let mut conn = setup_test_db();

        let input = CreateLocalSessionInput {
            id: None,
            human_id: "human-123".to_string(),
            agent_pub_key: "agent-456".to_string(),
            doorway_url: "https://doorway.example.com".to_string(),
            doorway_id: Some("doorway-1".to_string()),
            identifier: "user@example.com".to_string(),
            display_name: Some("Test User".to_string()),
            profile_image_hash: None,
            bootstrap_url: Some("https://bootstrap.example.com".to_string()),
        };

        let session = create_session(&mut conn, input).expect("Failed to create session");

        assert_eq!(session.human_id, "human-123");
        assert_eq!(session.agent_pub_key, "agent-456");
        assert_eq!(session.identifier, "user@example.com");
        assert_eq!(session.is_active, 1);

        // Get active session
        let active = get_active_session(&mut conn)
            .expect("Failed to get active session")
            .expect("No active session found");
        assert_eq!(active.id, session.id);
    }

    #[test]
    fn test_only_one_active_session() {
        let mut conn = setup_test_db();

        // Create first session
        let input1 = CreateLocalSessionInput {
            id: None,
            human_id: "human-1".to_string(),
            agent_pub_key: "agent-1".to_string(),
            doorway_url: "https://doorway1.example.com".to_string(),
            doorway_id: None,
            identifier: "user1@example.com".to_string(),
            display_name: None,
            profile_image_hash: None,
            bootstrap_url: None,
        };
        let session1 = create_session(&mut conn, input1).expect("Failed to create session 1");
        assert_eq!(session1.is_active, 1);

        // Create second session (should deactivate first)
        let input2 = CreateLocalSessionInput {
            id: None,
            human_id: "human-2".to_string(),
            agent_pub_key: "agent-2".to_string(),
            doorway_url: "https://doorway2.example.com".to_string(),
            doorway_id: None,
            identifier: "user2@example.com".to_string(),
            display_name: None,
            profile_image_hash: None,
            bootstrap_url: None,
        };
        let session2 = create_session(&mut conn, input2).expect("Failed to create session 2");
        assert_eq!(session2.is_active, 1);

        // Check session1 is now inactive
        let session1_updated = get_session_by_id(&mut conn, &session1.id)
            .expect("Failed to get session 1")
            .expect("Session 1 not found");
        assert_eq!(session1_updated.is_active, 0);

        // Only one active session
        let active = get_active_session(&mut conn)
            .expect("Failed to get active session")
            .expect("No active session found");
        assert_eq!(active.id, session2.id);
    }

    #[test]
    fn test_activate_session() {
        let mut conn = setup_test_db();

        // Create and then deactivate a session
        let input = CreateLocalSessionInput {
            id: None,
            human_id: "human-123".to_string(),
            agent_pub_key: "agent-456".to_string(),
            doorway_url: "https://doorway.example.com".to_string(),
            doorway_id: None,
            identifier: "user@example.com".to_string(),
            display_name: None,
            profile_image_hash: None,
            bootstrap_url: None,
        };
        let session = create_session(&mut conn, input).expect("Failed to create session");
        deactivate_session(&mut conn, &session.id).expect("Failed to deactivate");

        // Verify deactivated
        let deactivated = get_session_by_id(&mut conn, &session.id)
            .expect("Query failed")
            .expect("Session not found");
        assert_eq!(deactivated.is_active, 0);

        // Reactivate
        let reactivated = activate_session(&mut conn, &session.id)
            .expect("Failed to activate");
        assert_eq!(reactivated.is_active, 1);
    }
}
