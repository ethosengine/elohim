//! Fixtures Generator for Rust-Native Seed Data
//!
//! Generates Rust code from JSON fixture files with compile-time validation.
//! This eliminates the need for a separate TypeScript seeder while providing
//! type safety and compile-time schema validation.
//!
//! # Content Architecture Philosophy
//!
//! The DNA validates **metadata**, not **content**:
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────┐
//! │  DNA (Holochain)          Cache Layer           Client          │
//! │  ────────────────         ───────────           ──────          │
//! │                                                                 │
//! │  Metadata:                Blobs:                Rendering:      │
//! │  - id (required)          - video.mp4           - format hint   │
//! │  - title (required)       - app.zip             - graceful deg  │
//! │  - format_hint (any)      - quiz.json           - fallbacks     │
//! │  - blob_hash (optional)   - feature.gherkin                     │
//! │  - provenance (signed)                                          │
//! └─────────────────────────────────────────────────────────────────┘
//! ```
//!
//! This means:
//! - `content_format` accepts ANY string (client hint, not validation)
//! - New formats don't require DNA upgrades
//! - Blobs are stored in cache layer, not DHT
//! - DNA focuses on provenance, not content rendering
//!
//! # The Pattern
//!
//! Instead of:
//! ```text
//! JSON files → TypeScript seeder → WebSocket → Holochain
//! (runtime validation, external process, network overhead)
//! ```
//!
//! We get:
//! ```text
//! JSON files → hc-rna fixtures → Rust code → WASM (embedded)
//! (compile-time METADATA validation, no external process, no network)
//! ```
//!
//! # Generated Code Structure
//!
//! ```rust,ignore
//! // Generated by hc-rna fixtures
//! use once_cell::sync::Lazy;
//! use content_store_integrity::Content;
//!
//! /// Embedded, validated JSON (compile-time checked)
//! const CONTENT_JSON: &str = include_str!("../../fixtures/content.json");
//!
//! /// Parsed fixtures (lazy, parse-once)
//! pub static SEED_CONTENT: Lazy<Vec<Content>> = Lazy::new(|| {
//!     serde_json::from_str(CONTENT_JSON).unwrap()
//! });
//!
//! /// First-agent seeding function
//! pub fn seed_content() -> ExternResult<u32> { ... }
//! ```

use crate::analyzer::{EntryTypeSchema, FieldType};
use serde_json::Value;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Result of fixture validation
#[derive(Debug)]
pub struct FixtureValidation {
    pub file_path: String,
    pub entry_type: String,
    pub valid: bool,
    pub errors: Vec<String>,
}

/// Validate a JSON fixture file against a DNA schema
pub fn validate_fixture(
    fixture_path: &Path,
    entry_type: &EntryTypeSchema,
    field_mappings: &HashMap<String, String>,  // camelCase → snake_case
) -> FixtureValidation {
    let mut result = FixtureValidation {
        file_path: fixture_path.display().to_string(),
        entry_type: entry_type.name.clone(),
        valid: true,
        errors: Vec::new(),
    };

    // Read and parse JSON
    let json_str = match fs::read_to_string(fixture_path) {
        Ok(s) => s,
        Err(e) => {
            result.valid = false;
            result.errors.push(format!("Failed to read file: {}", e));
            return result;
        }
    };

    let json: Value = match serde_json::from_str(&json_str) {
        Ok(v) => v,
        Err(e) => {
            result.valid = false;
            result.errors.push(format!("Invalid JSON: {}", e));
            return result;
        }
    };

    let obj = match json.as_object() {
        Some(o) => o,
        None => {
            result.valid = false;
            result.errors.push("Fixture must be a JSON object".to_string());
            return result;
        }
    };

    // Validate each required field exists
    for field in entry_type.required_fields() {
        // Check both snake_case and camelCase versions
        let camel_name = field_mappings.get(&field.name)
            .map(|s| s.as_str())
            .unwrap_or(&field.name);

        let has_field = obj.contains_key(&field.name) || obj.contains_key(camel_name);

        if !has_field {
            result.valid = false;
            result.errors.push(format!(
                "Missing required field '{}' (or '{}')",
                field.name, camel_name
            ));
        }
    }

    // Validate field types
    for field in &entry_type.fields {
        let camel_name = field_mappings.get(&field.name)
            .map(|s| s.as_str())
            .unwrap_or(&field.name);

        let value = obj.get(&field.name).or_else(|| obj.get(camel_name));

        if let Some(v) = value {
            if let Err(e) = validate_field_type(v, &field.field_type) {
                result.valid = false;
                result.errors.push(format!("Field '{}': {}", field.name, e));
            }
        }
    }

    result
}

fn validate_field_type(value: &Value, expected: &FieldType) -> Result<(), String> {
    match expected {
        FieldType::String => {
            if !value.is_string() {
                return Err(format!("Expected string, got {:?}", value));
            }
        }
        FieldType::U32 | FieldType::U64 => {
            if !value.is_u64() && !value.is_i64() {
                return Err(format!("Expected integer, got {:?}", value));
            }
        }
        FieldType::F64 => {
            if !value.is_f64() && !value.is_i64() {
                return Err(format!("Expected number, got {:?}", value));
            }
        }
        FieldType::Bool => {
            if !value.is_boolean() {
                return Err(format!("Expected boolean, got {:?}", value));
            }
        }
        FieldType::Vec(inner) => {
            if let Some(arr) = value.as_array() {
                for (i, item) in arr.iter().enumerate() {
                    if let Err(e) = validate_field_type(item, inner) {
                        return Err(format!("[{}]: {}", i, e));
                    }
                }
            } else {
                return Err(format!("Expected array, got {:?}", value));
            }
        }
        FieldType::Option(inner) => {
            if !value.is_null() {
                validate_field_type(value, inner)?;
            }
        }
        FieldType::Custom(_) => {
            // Custom types - allow anything for now
        }
    }
    Ok(())
}

/// Generate Rust fixtures module from validated JSON files
pub fn generate_fixtures_module(
    fixtures_dir: &Path,
    entry_types: &[EntryTypeSchema],
    module_name: &str,
) -> Result<String, String> {
    let mut code = String::new();

    // Module header
    code.push_str(&format!(
        r#"//! {} - Auto-generated fixtures module
//!
//! Generated by hc-rna fixtures from JSON files.
//! DO NOT EDIT - regenerate with: hc-rna-fixtures --fixtures <path> --output <path>

use once_cell::sync::Lazy;
use hdk::prelude::*;
use content_store_integrity::*;
use std::collections::HashMap;

"#,
        module_name
    ));

    // Find JSON files and group by entry type
    let json_files: Vec<_> = fs::read_dir(fixtures_dir)
        .map_err(|e| format!("Failed to read fixtures dir: {}", e))?
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map(|x| x == "json").unwrap_or(false))
        .collect();

    // Generate embedded JSON constants
    code.push_str("// =============================================================================\n");
    code.push_str("// Embedded Fixture Data (compile-time validated)\n");
    code.push_str("// =============================================================================\n\n");

    for entry in &json_files {
        let path = entry.path();
        let stem = path.file_stem().unwrap().to_string_lossy();
        let const_name = stem.to_uppercase().replace("-", "_");
        let relative_path = path.strip_prefix(fixtures_dir).unwrap_or(&path);

        code.push_str(&format!(
            r#"/// Fixture: {}
const {}_JSON: &str = include_str!("{}");

"#,
            stem,
            const_name,
            relative_path.display()
        ));
    }

    // Generate lazy-parsed collections
    code.push_str("// =============================================================================\n");
    code.push_str("// Parsed Fixtures (lazy initialization)\n");
    code.push_str("// =============================================================================\n\n");

    // For Content entries specifically
    if entry_types.iter().any(|t| t.name == "Content") {
        code.push_str(r#"/// All content fixtures, parsed and ready for seeding
pub static SEED_CONTENT: Lazy<Vec<Content>> = Lazy::new(|| {
    let mut content = Vec::new();
    // Parse each embedded JSON file
    // (Add parsing logic for each constant)
    content
});

"#);
    }

    // Generate seeding function
    code.push_str("// =============================================================================\n");
    code.push_str("// Seeding Functions\n");
    code.push_str("// =============================================================================\n\n");

    code.push_str(r#"/// Result of a seeding operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SeedResult {
    /// Content was seeded successfully
    Seeded { count: u32 },
    /// Content was already seeded (idempotent)
    AlreadySeeded,
    /// Seeding failed
    Failed { error: String },
}

/// Seed marker path for idempotency
const SEED_MARKER_PATH: &str = "fixtures_seeded_v1";

/// Check if fixtures have already been seeded
pub fn is_seeded() -> ExternResult<bool> {
    let path = Path::from(SEED_MARKER_PATH);
    let path_hash = path.path_entry_hash()?;
    Ok(get(path_hash, GetOptions::default())?.is_some())
}

/// Seed all fixtures (idempotent - safe to call multiple times)
///
/// This function:
/// 1. Checks if already seeded (returns early if so)
/// 2. Creates all content entries from embedded fixtures
/// 3. Creates indexes (links by type, tags, etc.)
/// 4. Marks as seeded to prevent re-seeding
#[hdk_extern]
pub fn seed_fixtures(_: ()) -> ExternResult<SeedResult> {
    // Idempotency check
    if is_seeded()? {
        return Ok(SeedResult::AlreadySeeded);
    }

    let mut count = 0u32;

    // Seed content
    for content in SEED_CONTENT.iter() {
        create_entry(EntryTypes::Content(content.clone()))?;
        count += 1;
    }

    // Create seed marker
    let path = Path::from(SEED_MARKER_PATH);
    path.ensure()?;

    Ok(SeedResult::Seeded { count })
}

/// Force re-seed (removes marker and seeds again)
/// Use with caution - creates duplicate entries if called on already-seeded DHT
#[hdk_extern]
pub fn force_reseed(_: ()) -> ExternResult<SeedResult> {
    // Note: Can't actually delete in Holochain, but we can seed anyway
    // This is mainly for development/testing

    let mut count = 0u32;

    for content in SEED_CONTENT.iter() {
        create_entry(EntryTypes::Content(content.clone()))?;
        count += 1;
    }

    Ok(SeedResult::Seeded { count })
}
"#);

    Ok(code)
}

/// Standard field name mappings (camelCase to snake_case)
pub fn default_field_mappings() -> HashMap<String, String> {
    let mut m = HashMap::new();
    m.insert("content_type".to_string(), "contentType".to_string());
    m.insert("content_format".to_string(), "contentFormat".to_string());
    m.insert("source_path".to_string(), "sourcePath".to_string());
    m.insert("related_node_ids".to_string(), "relatedNodeIds".to_string());
    m.insert("author_id".to_string(), "authorId".to_string());
    m.insert("trust_score".to_string(), "trustScore".to_string());
    m.insert("estimated_minutes".to_string(), "estimatedMinutes".to_string());
    m.insert("thumbnail_url".to_string(), "thumbnailUrl".to_string());
    m.insert("metadata_json".to_string(), "metadataJson".to_string());
    m.insert("created_at".to_string(), "createdAt".to_string());
    m.insert("updated_at".to_string(), "updatedAt".to_string());
    m.insert("schema_version".to_string(), "schemaVersion".to_string());
    m.insert("validation_status".to_string(), "validationStatus".to_string());
    m
}

/// Fields that have automatic defaults applied by seeder/zome
/// These are NOT required in seed JSON files
pub fn fields_with_defaults() -> HashMap<String, String> {
    let mut m = HashMap::new();
    // DNA-internal fields with sensible defaults
    m.insert("reach".to_string(), "\"commons\"".to_string());
    m.insert("trust_score".to_string(), "1.0".to_string());
    m.insert("metadata_json".to_string(), "\"{}\"".to_string());
    m.insert("created_at".to_string(), "now()".to_string());
    m.insert("updated_at".to_string(), "now()".to_string());
    m.insert("schema_version".to_string(), "1".to_string());
    m.insert("validation_status".to_string(), "\"Valid\"".to_string());
    // Optional fields that can be empty
    m.insert("summary".to_string(), "None".to_string());
    m.insert("source_path".to_string(), "None".to_string());
    m.insert("author_id".to_string(), "None".to_string());
    m.insert("estimated_minutes".to_string(), "None".to_string());
    m.insert("thumbnail_url".to_string(), "None".to_string());
    m
}

/// Fields that are truly required in seed JSON files (metadata validation)
pub fn truly_required_fields() -> Vec<&'static str> {
    vec![
        "id",      // Identity - must be unique
        "title",   // Human-readable name
    ]
}

/// Fields that are hints for clients, not validated by DNA
/// These accept ANY value - the client decides how to handle them
pub fn client_hint_fields() -> Vec<&'static str> {
    vec![
        "content_format",  // Rendering hint (markdown, gherkin, html5-app, etc.)
        "content_type",    // Content category (epic, concept, scenario, etc.)
    ]
}

/// Fields related to blob/cache resolution
/// Presence indicates content needs to be fetched from cache layer
pub fn blob_resolution_fields() -> Vec<&'static str> {
    vec![
        "blob_hash",       // Hash of the actual content blob
        "blob_url",        // Direct URL to blob (fallback)
        "entry_point",     // For html5-app: which file to load
    ]
}

/// Validation mode for fixtures
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ValidationMode {
    /// Strict: Validate all DNA schema fields
    Strict,
    /// Metadata: Only validate truly required fields, accept any hints
    Metadata,
    /// Loose: Accept anything with an id field
    Loose,
}

impl Default for ValidationMode {
    fn default() -> Self {
        ValidationMode::Metadata
    }
}

/// Result of fixture analysis (not just validation)
#[derive(Debug, Default)]
pub struct FixtureAnalysis {
    /// Total files analyzed
    pub total_files: usize,
    /// Files with valid metadata
    pub valid_metadata: usize,
    /// Files with blob references (need cache resolution)
    pub with_blob_refs: usize,
    /// Content format distribution
    pub format_distribution: HashMap<String, usize>,
    /// Content type distribution
    pub type_distribution: HashMap<String, usize>,
    /// Files missing required fields
    pub missing_required: Vec<(String, Vec<String>)>,
}

/// Analyze a fixture file with metadata-focused validation
pub fn analyze_fixture(
    fixture_path: &std::path::Path,
    mode: ValidationMode,
) -> Result<FixtureFileAnalysis, String> {
    let json_str = std::fs::read_to_string(fixture_path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let json: Value = serde_json::from_str(&json_str)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let obj = json.as_object()
        .ok_or_else(|| "Fixture must be a JSON object".to_string())?;

    let mut analysis = FixtureFileAnalysis {
        file_path: fixture_path.display().to_string(),
        valid: true,
        missing_required: Vec::new(),
        content_format: None,
        content_type: None,
        has_blob_ref: false,
        has_inline_content: false,
    };

    // Check required fields based on mode
    let required = match mode {
        ValidationMode::Strict => truly_required_fields(),
        ValidationMode::Metadata => truly_required_fields(),
        ValidationMode::Loose => vec!["id"],
    };

    for field in required {
        // Check both snake_case and camelCase
        let camel = to_camel_case(field);
        if !obj.contains_key(field) && !obj.contains_key(&camel) {
            analysis.valid = false;
            analysis.missing_required.push(field.to_string());
        }
    }

    // Extract hints (any value accepted)
    if let Some(format) = obj.get("contentFormat").or_else(|| obj.get("content_format")) {
        analysis.content_format = format.as_str().map(|s| s.to_string());
    }
    if let Some(ctype) = obj.get("contentType").or_else(|| obj.get("content_type")) {
        analysis.content_type = ctype.as_str().map(|s| s.to_string());
    }

    // Check for blob references
    for field in blob_resolution_fields() {
        let camel = to_camel_case(field);
        if obj.contains_key(field) || obj.contains_key(&camel) {
            analysis.has_blob_ref = true;
            break;
        }
    }

    // Check for inline content
    if obj.contains_key("content") {
        if let Some(content) = obj.get("content") {
            analysis.has_inline_content = content.is_string() &&
                content.as_str().map(|s| !s.is_empty()).unwrap_or(false);
        }
    }

    Ok(analysis)
}

/// Analysis result for a single fixture file
#[derive(Debug)]
pub struct FixtureFileAnalysis {
    pub file_path: String,
    pub valid: bool,
    pub missing_required: Vec<String>,
    pub content_format: Option<String>,
    pub content_type: Option<String>,
    pub has_blob_ref: bool,
    pub has_inline_content: bool,
}

/// Convert snake_case to camelCase
fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;
    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap_or(c));
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}

/// Analyze all fixtures in a directory
pub fn analyze_fixtures_directory(
    dir: &std::path::Path,
    mode: ValidationMode,
) -> Result<FixtureAnalysis, String> {
    let mut analysis = FixtureAnalysis::default();

    let entries = std::fs::read_dir(dir)
        .map_err(|e| format!("Failed to read directory: {}", e))?;

    for entry in entries.filter_map(|e| e.ok()) {
        let path = entry.path();
        if path.extension().map(|x| x == "json").unwrap_or(false) {
            analysis.total_files += 1;

            match analyze_fixture(&path, mode) {
                Ok(file_analysis) => {
                    if file_analysis.valid {
                        analysis.valid_metadata += 1;
                    } else {
                        analysis.missing_required.push((
                            path.file_name().unwrap().to_string_lossy().to_string(),
                            file_analysis.missing_required,
                        ));
                    }

                    if file_analysis.has_blob_ref {
                        analysis.with_blob_refs += 1;
                    }

                    if let Some(format) = file_analysis.content_format {
                        *analysis.format_distribution.entry(format).or_insert(0) += 1;
                    }

                    if let Some(ctype) = file_analysis.content_type {
                        *analysis.type_distribution.entry(ctype).or_insert(0) += 1;
                    }
                }
                Err(_) => {
                    // Count as invalid
                    analysis.missing_required.push((
                        path.file_name().unwrap().to_string_lossy().to_string(),
                        vec!["(parse error)".to_string()],
                    ));
                }
            }
        }
    }

    Ok(analysis)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_field_type_string() {
        let value = serde_json::json!("hello");
        assert!(validate_field_type(&value, &FieldType::String).is_ok());

        let value = serde_json::json!(123);
        assert!(validate_field_type(&value, &FieldType::String).is_err());
    }

    #[test]
    fn test_validate_field_type_array() {
        let value = serde_json::json!(["a", "b", "c"]);
        let expected = FieldType::Vec(Box::new(FieldType::String));
        assert!(validate_field_type(&value, &expected).is_ok());

        let value = serde_json::json!([1, 2, 3]);
        assert!(validate_field_type(&value, &expected).is_err());
    }

    #[test]
    fn test_validate_field_type_option() {
        let expected = FieldType::Option(Box::new(FieldType::String));

        let value = serde_json::json!(null);
        assert!(validate_field_type(&value, &expected).is_ok());

        let value = serde_json::json!("hello");
        assert!(validate_field_type(&value, &expected).is_ok());

        let value = serde_json::json!(123);
        assert!(validate_field_type(&value, &expected).is_err());
    }
}
