/**
 * Elohim Steward Pipeline
 *
 * Builds steward apps (desktop + mobile) using tauri-plugin-holochain.
 * For those who run their own Holochain nodes as stewards of co-creation.
 *
 * This is a multibranch pipeline within the elohim mono-repo.
 * Jenkins job configured to look at steward/Jenkinsfile
 *
 * Platforms:
 *   - Linux: AppImage, .deb (default)
 *   - macOS: .dmg (future, requires macOS agent)
 *   - Windows: .exe (future, requires Windows agent)
 *   - Android: .apk (future, requires Android SDK)
 *
 * Dependencies (fetched from other pipelines in mono-repo):
 *   - elohim.happ from elohim/holochain pipeline artifacts
 *   - Angular dist from elohim/elohim-app pipeline artifacts
 */

pipeline {
    agent {
        kubernetes {
            cloud 'kubernetes'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  serviceAccount: jenkins-deployer
  nodeSelector:
    node-type: operations
  tolerations:
    - key: "workload-type"
      operator: "Equal"
      value: "build"
      effect: "NoSchedule"
  volumes:
    - name: cargo-cache
      persistentVolumeClaim:
        claimName: cargo-cache-holochain
    - name: fuse
      hostPath:
        path: /dev/fuse
        type: CharDevice
  containers:
    - name: builder
      image: harbor.ethosengine.com/ethosengine/ci-builder-nix:latest
      command: [cat]
      tty: true
      securityContext:
        privileged: true
      resources:
        requests:
          memory: "8Gi"
          cpu: "4"
        limits:
          memory: "16Gi"
          cpu: "8"
      volumeMounts:
        - name: cargo-cache
          mountPath: /root/.cargo
        - name: fuse
          mountPath: /dev/fuse
'''
        }
    }

    environment {
        PATH = "/nix/var/nix/profiles/default/bin:${env.PATH}"
        BRANCH_NAME = "${env.BRANCH_NAME ?: 'main'}"
        // Required for AppImage bundling in containerized environments without FUSE
        APPIMAGE_EXTRACT_AND_RUN = '1'
    }

    options {
        timeout(time: 90, unit: 'MINUTES')
        disableConcurrentBuilds()
        overrideIndexTriggers(false)  // Only manual triggers - no webhook/branch indexing
    }

    parameters {
        string(
            name: 'HAPP_VERSION',
            defaultValue: 'dev-latest',
            description: 'hApp version/tag to fetch from holochain pipeline'
        )
        string(
            name: 'UI_VERSION',
            defaultValue: 'dev-latest',
            description: 'UI version/tag to fetch from elohim-app pipeline'
        )
        booleanParam(
            name: 'PUBLISH_RELEASE',
            defaultValue: false,
            description: 'Publish to GitHub Releases'
        )
    }

    stages {
        stage('Check Trigger') {
            steps {
                script {
                    // Steward builds are release artifacts - only run when manually triggered
                    def isManualTrigger = currentBuild.getBuildCauses().any { cause ->
                        cause._class.contains('UserIdCause')
                    }

                    if (!isManualTrigger) {
                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        â­ï¸ SKIPPING STEWARD BUILD
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        Steward builds desktop/mobile release artifacts and should
                        only run when explicitly triggered for a release.

                        To build Steward:
                        1. Go to Jenkins â†’ elohim-steward â†’ your branch
                        2. Click "Build with Parameters"
                        3. Set HAPP_VERSION, UI_VERSION as needed
                        4. Check PUBLISH_RELEASE if releasing to GitHub

                        Triggered by: ${currentBuild.getBuildCauses()*.shortDescription.join(', ')}
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """
                        currentBuild.result = 'NOT_BUILT'
                        error('Pipeline skipped - Steward only runs on manual trigger')
                    }

                    echo "âœ… Manual trigger detected: ${currentBuild.getBuildCauses()*.shortDescription.join(', ')}"
                }
            }
        }

        stage('Checkout') {
            steps {
                container('builder') {
                    script {
                        sh 'git config --global --add safe.directory "*"'
                        checkout scm

                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ðŸ“¦ STEWARD BUILD CONTEXT
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        Branch: ${env.BRANCH_NAME}
                        hApp Version: ${params.HAPP_VERSION}
                        UI Version: ${params.UI_VERSION}
                        Publish Release: ${params.PUBLISH_RELEASE}
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """
                    }
                }
            }
        }

        stage('Setup Nix Cache') {
            // Manual-only pipeline - no changeset conditions needed
            steps {
                container('builder') {
                    dir('steward') {
                        script {
                            echo 'Configuring Nix with Holochain and Darksoil Cachix...'
                            sh '''
                                nix --version
                                echo "Nix config:"
                                nix show-config | grep -E "(substituters|trusted-public-keys)" || true
                            '''
                        }
                    }
                }
            }
        }

        stage('ðŸ“¦ Fetch hApp Artifact') {
            // Manual-only pipeline - no changeset conditions needed
            steps {
                container('builder') {
                    dir('steward') {
                        script {
                            // Read HAPP_VERSION from VERSION file
                            def versionContent = readFile('../VERSION').trim()
                            def versionMap = [:]
                            versionContent.split('\n').each { line ->
                                def parts = line.split('=')
                                if (parts.length == 2) {
                                    versionMap[parts[0].trim()] = parts[1].trim()
                                }
                            }
                            def baseVersion = versionMap['HAPP_VERSION'] ?: versionMap['APP_VERSION'] ?: '1.0.0'

                            // Use floating tag from DNA pipeline, or explicit override
                            def happVersion
                            if (params.HAPP_VERSION && params.HAPP_VERSION != 'dev-latest') {
                                happVersion = params.HAPP_VERSION
                            } else {
                                happVersion = (env.BRANCH_NAME == 'main') ? 'latest' : 'dev-latest'
                            }

                            echo """
                            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            ðŸ“¦ FETCHING hApp ARTIFACT FROM HARBOR
                            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            Target version: ${happVersion}
                            Branch: ${env.BRANCH_NAME}
                            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            """

                            // Ensure workdir exists
                            sh 'mkdir -p workdir'

                            // Install oras CLI if not present
                            sh '''
                                if ! command -v oras &> /dev/null; then
                                    echo "Installing oras CLI..."
                                    curl -sLO https://github.com/oras-project/oras/releases/download/v1.1.0/oras_1.1.0_linux_amd64.tar.gz
                                    tar -xzf oras_1.1.0_linux_amd64.tar.gz
                                    chmod +x oras
                                    mv oras /usr/local/bin/
                                    rm oras_1.1.0_linux_amd64.tar.gz
                                fi
                            '''

                            // Strategy 1: Fetch from Harbor (primary)
                            echo "ðŸ”„ Fetching from Harbor: harbor.ethosengine.com/ethosengine/elohim-happ:${happVersion}"

                            def fetched = false
                            withCredentials([usernamePassword(
                                credentialsId: 'harbor-robot-registry',
                                usernameVariable: 'HARBOR_USER',
                                passwordVariable: 'HARBOR_PASS'
                            )]) {
                                def result = sh(script: """
                                    oras login harbor.ethosengine.com -u \$HARBOR_USER -p \$HARBOR_PASS
                                    cd workdir
                                    oras pull harbor.ethosengine.com/ethosengine/elohim-happ:${happVersion}
                                """, returnStatus: true)
                                fetched = (result == 0 && fileExists('workdir/elohim.happ'))
                            }

                            if (fetched) {
                                def fileSize = sh(script: 'ls -lh workdir/elohim.happ | awk \'{print \$5}\'', returnStdout: true).trim()
                                echo """
                                âœ… hApp fetched from Harbor (${fileSize})

                                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                â±ï¸  Artifact fetch completed
                                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                """
                            } else {
                                // Strategy 2: Fallback to local build
                                echo """
                                âš ï¸  Artifact not found in Harbor
                                âš ï¸  Falling back to local hApp build (20-40 minutes)

                                This should rarely happen. If you see this often:
                                - Check holochain DNA pipeline succeeded
                                - Verify artifacts are pushed to Harbor
                                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                """

                                sh '''#!/usr/bin/env bash
                                    set -euo pipefail

                                    export HOME="${HOME:-/root}"
                                    mkdir -p "$HOME"
                                    echo "[safe]" > "$HOME/.gitconfig"
                                    echo "    directory = *" >> "$HOME/.gitconfig"
                                    export GIT_CONFIG_GLOBAL="$HOME/.gitconfig"

                                    cd ../holochain/dna/elohim

                                    echo "Building hApp from source (this will take 20-40 minutes)..."
                                    nix develop --accept-flake-config --command bash -c '
                                        set -euo pipefail
                                        cargo build --release --target wasm32-unknown-unknown
                                        hc dna pack . -o workdir/lamad.dna
                                        hc app pack workdir -o elohim.happ
                                    '

                                    cp elohim.happ ../../../steward/workdir/elohim.happ
                                    echo "âœ… Local hApp build completed"
                                '''
                            }

                            // Verify artifact exists (error if missing)
                            if (!fileExists('workdir/elohim.happ')) {
                                error "hApp artifact not found after fetch/build attempt"
                            }

                            sh 'echo "Final artifact:"; ls -lh workdir/elohim.happ'
                        }
                    }
                }
            }
        }

        stage('ðŸ“± Fetch UI') {
            // Manual-only pipeline - no changeset conditions needed
            steps {
                container('builder') {
                    dir('steward') {
                        script {
                            echo """
                            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            ðŸ“± FETCHING UI FROM ELOHIM-APP PIPELINE
                            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            """

                            def artifactUrl = "https://jenkins.ethosengine.com/job/elohim-app/job/${env.BRANCH_NAME}/lastSuccessfulBuild/artifact/*zip*/archive.zip"

                            sh 'mkdir -p ui'

                            echo "Fetching UI from: ${artifactUrl}"

                            def fetched = sh(
                                script: """
                                    set +e
                                    wget --timeout=30 --tries=3 -O /tmp/ui-archive.zip '${artifactUrl}' 2>&1
                                    exit_code=\$?
                                    set -e
                                    exit \$exit_code
                                """,
                                returnStatus: true
                            ) == 0

                            if (fetched) {
                                sh '''
                                    cd /tmp
                                    unzip -o ui-archive.zip
                                    # Find the browser output and copy to steward/ui
                                    if [ -d archive/dist/elohim-app/browser ]; then
                                        cp -r archive/dist/elohim-app/browser/* /home/jenkins/agent/workspace/*/steward/ui/ 2>/dev/null || \
                                        cp -r archive/dist/elohim-app/browser/* $WORKSPACE/steward/ui/
                                    fi
                                    rm -rf archive ui-archive.zip
                                '''
                                echo "âœ… UI fetched from elohim-app pipeline"
                            } else {
                                echo "âš ï¸ Could not fetch UI from pipeline - building locally"
                                sh '''
                                    cd ..

                                    # 1. Init and build sophia (UMD bundle for prebuild check)
                                    git submodule update --init sophia
                                    cd sophia
                                    if ! command -v pnpm > /dev/null 2>&1; then
                                        npm install -g pnpm
                                    fi
                                    pnpm install --frozen-lockfile
                                    pnpm build
                                    pnpm --filter @ethosengine/sophia-element build:umd
                                    cd ..

                                    # 2. Install elohim-library deps (provides @angular/core for elohim-service)
                                    cd elohim-library && npm ci && cd ..

                                    # 3. Build storage-client-ts (provides @elohim/storage-client/generated)
                                    cd holochain/sdk/storage-client-ts && npm ci && npm run build && cd ../../..

                                    # 4. Build elohim-app
                                    cd elohim-app
                                    npm ci
                                    npm run build
                                    cp -r dist/elohim-app/browser/* ../steward/ui/
                                '''
                            }

                            sh 'echo "UI directory:"; ls -la ui/ | head -20'
                        }
                    }
                }
            }
        }

        stage('Build Steward App - Linux') {
            // Manual-only pipeline - no changeset conditions needed
            steps {
                container('builder') {
                    dir('steward') {
                        script {
                            echo 'Building Steward app with Nix + Tauri...'
                            echo 'First build may take 30-60 minutes. Subsequent builds use cache.'

                            sh '''#!/usr/bin/env bash
                                set -euo pipefail

                                # Fix git safe.directory for containerized builds where workspace owner differs
                                # Create explicit gitconfig file and point GIT_CONFIG_GLOBAL to it
                                export HOME="${HOME:-/root}"
                                mkdir -p "$HOME"
                                echo "[safe]" > "$HOME/.gitconfig"
                                echo "    directory = *" >> "$HOME/.gitconfig"
                                export GIT_CONFIG_GLOBAL="$HOME/.gitconfig"

                                echo "=== Git config set ==="
                                cat "$GIT_CONFIG_GLOBAL"

                                # Set build environment based on branch
                                # dev/feature branches -> dev endpoints
                                # main -> production endpoints (default)
                                if [ "$BRANCH_NAME" = "main" ]; then
                                    echo "=== Building for PRODUCTION environment ==="
                                    ELOHIM_ENV="prod"
                                else
                                    echo "=== Building for DEV environment ==="
                                    ELOHIM_ENV="dev"
                                fi
                                echo "ELOHIM_ENV=$ELOHIM_ENV"

                                # Write env cleanup script to temp file (avoids single-quote
                                # nesting issues inside bash -c '...' block)
                                cat > /tmp/dedup-env.sh << 'DEDUP_SCRIPT'
#!/usr/bin/env bash
# Deduplicate large nix env vars from stacked devShells
# Uses ' -' boundary split to preserve multi-word flags (-isystem /path)
for var in NIX_LDFLAGS NIX_LDFLAGS_FOR_TARGET NIX_CFLAGS_COMPILE NIX_CFLAGS_COMPILE_FOR_TARGET; do
    val="${!var:-}"
    if [ -n "$val" ]; then
        before=${#val}
        deduped=$(printf '%s\n' "$val" | awk '{gsub(/ -/, "\n-"); print}' | awk '!seen[$0]++' | tr '\n' ' ' | sed 's/ $//')
        after=${#deduped}
        echo "${var}: ${before} -> ${after} chars"
        export "$var=$deduped"
    fi
done
# Deduplicate PATH (colon-separated) with safety check
ORIG_PATH="$PATH"
before=${#PATH}
NEW_PATH=$(printf '%s' "$PATH" | tr ':' '\n' | awk '!seen[$0]++' | tr '\n' ':' | sed 's/:$//')
after=${#NEW_PATH}
echo "PATH: ${before} -> ${after} chars"
if PATH="$NEW_PATH" command -v wc > /dev/null 2>&1; then
    export PATH="$NEW_PATH"
else
    echo "WARNING: deduped PATH broken, keeping original"
fi
DEDUP_SCRIPT

                                echo "=== Entering Nix development shell ==="
                                # Pass ELOHIM_ENV to nix shell for Rust compile-time config
                                ELOHIM_ENV="$ELOHIM_ENV" nix develop --accept-flake-config --command bash -c '
                                    set -euo pipefail

                                    echo "=== Installing npm dependencies ==="
                                    npm install

                                    echo ""
                                    echo "=== Using committed app icons ==="
                                    # Icons are pre-generated and committed in src-tauri/icons/
                                    # Generated from elohim_protocol_app_logo.png with black background
                                    ls -la src-tauri/icons/*.png | head -5 || echo "Warning: icons not found"

                                    echo ""
                                    echo "=== Debug: Testing linuxdeploy & plugin ==="
                                    # Download and test both linuxdeploy and the appimage plugin
                                    curl -L -o /tmp/linuxdeploy https://github.com/tauri-apps/binary-releases/releases/download/linuxdeploy/linuxdeploy-x86_64.AppImage
                                    curl -L -o /tmp/linuxdeploy-plugin-appimage https://github.com/linuxdeploy/linuxdeploy-plugin-appimage/releases/download/continuous/linuxdeploy-plugin-appimage-x86_64.AppImage
                                    chmod +x /tmp/linuxdeploy /tmp/linuxdeploy-plugin-appimage

                                    echo "FUSE device:"
                                    ls -la /dev/fuse || echo "FUSE device not found"

                                    echo ""
                                    echo "Testing linuxdeploy..."
                                    /tmp/linuxdeploy --version 2>&1 || echo "linuxdeploy failed with exit code $?"

                                    echo ""
                                    echo "Testing linuxdeploy-plugin-appimage..."
                                    /tmp/linuxdeploy-plugin-appimage --help 2>&1 || echo "plugin failed with exit code $?"

                                    echo "=== End debug ==="

                                    echo ""
                                    echo "=== Building Tauri app (compile only) ==="
                                    # Workaround: Nix stacked devShells (holonix + holochainTauriDev)
                                    # cause two problems that exceed posix_spawn limits:
                                    #
                                    # 1. Small vars accumulate (deps*, *Phase, shellHook, etc.)
                                    # 2. Large vars DUPLICATE (NIX_LDFLAGS, NIX_CFLAGS_COMPILE, PATH)
                                    #    because each inputsFrom shell concatenates its full -L/-I paths.
                                    #    A single var >128KB hits Linux MAX_ARG_STRLEN, causing E2BIG.
                                    #
                                    # Fix: unset small nix internals + deduplicate the large vars.
                                    echo "Env size before cleanup: $(env | wc -c) bytes ($(env | wc -l) vars)"

                                    # Step 1: Unset nix mkShell internal vars not needed by cargo/gcc
                                    for var in $(env | cut -d= -f1); do
                                        case "$var" in
                                            deps*|propagated*|buildInputs|nativeBuildInputs|\
                                            configureFlags|mesonFlags|cmakeFlags|\
                                            *Phase|*Phases|phases|\
                                            stdenv|builder|outputs|out|system|\
                                            __structuredAttrs|preferLocalBuild|allowSubstitutes|\
                                            dontAddDisableDepTrack|initialPath|shellHook|\
                                            IN_NIX_SHELL|NIX_BUILD_TOP|NIX_STORE|NIX_LOG_FD|\
                                            NIX_BUILD_CORES|NIX_ENFORCE_PURITY|SOURCE_DATE_EPOCH|\
                                            strictDeps|dontPatch*|dontStrip|dontMove*|\
                                            forceShare|wrapPrefixVariables|NIX_HARDENING_ENABLE)
                                                unset "$var" 2>/dev/null ;;
                                        esac
                                    done

                                    # Step 2: Deduplicate large vars from stacked nix shells
                                    # Script written before nix develop to avoid bash -c quoting issues
                                    source /tmp/dedup-env.sh

                                    echo "Env size after cleanup: $(env | wc -c) bytes ($(env | wc -l) vars)"

                                    # Build without bundling first
                                    npx tauri build --no-bundle --verbose

                                    echo ""
                                    echo "=== Patching binary for non-Nix systems ==="
                                    # Fix the interpreter path so binary works on standard Linux
                                    BINARY="src-tauri/target/release/elohim-steward"
                                    echo "Before patching:"
                                    patchelf --print-interpreter "$BINARY" || true
                                    patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 "$BINARY"
                                    echo "After patching:"
                                    patchelf --print-interpreter "$BINARY"

                                    echo ""
                                    echo "=== Bundling .deb package ==="
                                    # Now bundle with the patched binary
                                    npx tauri bundle --verbose

                                    echo ""
                                    echo "=== Build artifacts ==="
                                    ls -lh src-tauri/target/release/bundle/appimage/ || true
                                    ls -lh src-tauri/target/release/bundle/deb/ || true
                                '
                            '''

                            // Archive artifacts
                            archiveArtifacts artifacts: 'src-tauri/target/release/bundle/**/*', allowEmptyArchive: true
                            stash name: 'steward-linux', includes: 'src-tauri/target/release/bundle/**/*.AppImage,src-tauri/target/release/bundle/**/*.deb', allowEmpty: true

                            echo 'Steward build complete!'
                        }
                    }
                }
            }
        }

        stage('Publish GitHub Release') {
            when {
                allOf {
                    branch 'main'
                    expression { return params.PUBLISH_RELEASE == true }
                }
            }
            steps {
                container('builder') {
                    dir('steward') {
                        script {
                            def version = readFile('VERSION').trim()
                            echo "Publishing release steward-v${version} to GitHub..."

                            withCredentials([string(credentialsId: 'github-release-token', variable: 'GH_TOKEN')]) {
                                sh """#!/usr/bin/env bash
                                    set -euo pipefail

                                    # Install GitHub CLI if needed
                                    which gh || nix-env -iA nixpkgs.gh

                                    # Create release and upload assets (to elohim mono-repo)
                                    gh release create steward-v${version} \\
                                        --repo ethosengine/elohim \\
                                        --title "Elohim Steward v${version}" \\
                                        --generate-notes \\
                                        src-tauri/target/release/bundle/deb/*.deb \\
                                        src-tauri/target/release/bundle/appimage/*.AppImage
                                """
                            }

                            echo "Release steward-v${version} published!"
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Steward pipeline completed successfully"
        }
        failure {
            echo "Steward pipeline failed"
            echo "If this is a first-time build, it may need more time/resources for cache population"
        }
    }
}
