/**
 * Elohim Orchestrator Pipeline v2
 *
 * CENTRAL CONTROLLER for all Elohim mono-repo pipelines.
 * This is the ONLY pipeline that receives GitHub webhooks.
 *
 * Key Improvements:
 *   - Explicit deployment tracking with version verification
 *   - Complete changeset analysis (all commits since last build, not just HEAD~1)
 *   - Post-deployment health verification
 *   - Clear decision matrix showing what will be built and why
 *   - Deployment manifest comparing expected vs actual versions
 *
 * Dependency Graph:
 *   elohim-holochain (DNA/hApp, WASM)
 *       ‚îú‚îÄ‚îÄ‚ñ∫ elohim-edge (infrastructure) ‚îÄ‚îÄ‚îê
 *       ‚îú‚îÄ‚îÄ‚ñ∫ elohim (Angular app) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñ∫ elohim-genesis (seed + test)
 *       ‚îî‚îÄ‚îÄ‚ñ∫ elohim-steward (manual only)   ‚îÇ
 *                                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫
 */

// =============================================================================
// CONFIGURATION
// =============================================================================

import groovy.transform.Field

@Field def PIPELINES = [
    'elohim-holochain': [
        jenkinsPath: 'holochain/dna/Jenkinsfile',
        changePatterns: ['holochain/dna/', 'holochain/holochain-cache-core/', 'holochain/rna/'],
        artifacts: ['elohim.happ'],
        dependsOn: [],
        triggersGenesis: true,
        deploymentCheck: null  // No deployment, just artifacts
    ],
    'elohim-edge': [
        jenkinsPath: 'holochain/Jenkinsfile',
        changePatterns: ['holochain/doorway/', 'holochain/edgenode/', 'holochain/elohim-storage/', 'holochain/manifests/', 'holochain/crates/'],
        artifacts: ['elohim-doorway', 'elohim-edgenode', 'elohim-storage', 'elohim-happ-installer'],
        dependsOn: ['elohim-holochain'],
        triggersGenesis: true,
        deploymentCheck: [
            dev: 'https://doorway-dev.elohim.host/health',
            prod: 'https://doorway.elohim.host/health'
        ]
    ],
    'elohim': [
        jenkinsPath: 'Jenkinsfile',
        changePatterns: ['elohim-app/', 'elohim-library/', 'VERSION'],
        artifacts: ['elohim-app'],
        dependsOn: ['elohim-holochain'],
        triggersGenesis: true,
        deploymentCheck: [
            dev: 'https://alpha.elohim.host',
            prod: 'https://elohim.host'
        ]
    ],
    'elohim-genesis': [
        jenkinsPath: 'genesis/Jenkinsfile',
        changePatterns: ['genesis/', 'data/'],
        artifacts: [],
        dependsOn: ['elohim-holochain', 'elohim-edge', 'elohim'],
        triggersGenesis: false,
        deploymentCheck: null
    ],
    'elohim-steward': [
        jenkinsPath: 'steward/Jenkinsfile',
        changePatterns: ['steward/'],
        artifacts: ['steward-desktop'],
        dependsOn: ['elohim-holochain'],
        manualOnly: true,
        triggersGenesis: false,
        deploymentCheck: null
    ]
]

// Environment-specific endpoints for version checking
@Field def VERSION_ENDPOINTS = [
    'doorway-dev': 'https://doorway-dev.elohim.host/version',
    'doorway-prod': 'https://doorway.elohim.host/version',
    'app-dev': 'https://alpha.elohim.host/version.json',
    'app-prod': 'https://elohim.host/version.json'
]

@Field def HEALTH_ENDPOINTS = [
    'doorway-dev': 'https://doorway-dev.elohim.host/health',
    'doorway-prod': 'https://doorway.elohim.host/health',
    'alpha': 'https://alpha.elohim.host',
    'staging': 'https://staging.elohim.host',
    'prod': 'https://elohim.host'
]

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

def getGitCommitHash() {
    return sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
}

// CI Summary helpers for Claude triage
def categorizeFailure(String p) {
    ['elohim-holochain':'DNA_BUILD', 'elohim-edge':'INFRASTRUCTURE',
     'elohim':'APP_BUILD', 'elohim-genesis':'SEEDING', 'elohim-steward':'DESKTOP_BUILD'][p] ?: 'UNKNOWN'
}
def getRemediationHint(String p) {
    ['elohim-holochain':'Check RUSTFLAGS, cargo build locally',
     'elohim-edge':'Check hApp artifact, Harbor creds',
     'elohim':'Run npm run build locally',
     'elohim-genesis':'Check doorway-dev.elohim.host/health',
     'elohim-steward':'Check Tauri build, hApp artifact'][p] ?: 'Check logs'
}
def calculateTriagePriority(int f, int u) { f > 0 && u > 0 ? 'CRITICAL' : f > 0 ? 'HIGH' : u > 0 ? 'MEDIUM' : 'LOW' }

def getGitCommitHashFull() {
    return sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
}

/**
 * Analyze all changes since the last successful orchestrator build.
 * This ensures we catch all changes, not just the most recent commit.
 */
def analyzeChangeset() {
    // Try to get the commit from last successful build
    def lastSuccessfulCommit = null
    try {
        def lastSuccess = currentBuild.previousSuccessfulBuild
        if (lastSuccess) {
            // Get the commit hash from the last successful build
            lastSuccessfulCommit = lastSuccess.changeSets.collect { it.items.collect { item -> item.commitId } }.flatten().last()
        }
    } catch (Exception e) {
        echo "Could not get last successful commit: ${e.message}"
    }

    def changedFiles = []

    if (lastSuccessfulCommit) {
        echo "Comparing against last successful build commit: ${lastSuccessfulCommit}"
        changedFiles = sh(
            script: "git diff --name-only ${lastSuccessfulCommit}..HEAD 2>/dev/null || git diff --name-only HEAD~10",
            returnStdout: true
        ).trim().split('\n').findAll { it }
    } else {
        // Fallback: look at last 10 commits to be safe
        echo 'No previous successful build found, analyzing last 10 commits'
        changedFiles = sh(
            script: 'git diff --name-only HEAD~10 2>/dev/null || git diff --name-only HEAD',
            returnStdout: true
        ).trim().split('\n').findAll { it }
    }

    return changedFiles
}

/**
 * Determine which pipelines need to run based on changed files.
 * Returns a detailed map with reasoning.
 */
def analyzePipelineRequirements(changedFiles) {
    def analysis = [:]

    PIPELINES.each { name, config ->
        def matchedPatterns = []
        def matchedFiles = []

        changedFiles.each { file ->
            config.changePatterns.each { pattern ->
                if (file.startsWith(pattern)) {
                    if (!matchedPatterns.contains(pattern)) {
                        matchedPatterns.add(pattern)
                    }
                    matchedFiles.add(file)
                }
            }
        }

        analysis[name] = [
            shouldRun: !config.manualOnly && matchedPatterns.size() > 0,
            manualOnly: config.manualOnly ?: false,
            matchedPatterns: matchedPatterns,
            matchedFileCount: matchedFiles.size(),
            sampleFiles: matchedFiles.take(5),
            dependsOn: config.dependsOn ?: [],
            triggersGenesis: config.triggersGenesis ?: false
        ]
    }

    return analysis
}

/**
 * Check deployed version against expected commit
 */
def checkDeployedVersion(String endpoint, String expectedCommit) {
    try {
        def response = sh(
            script: "curl -sf '${endpoint}' 2>/dev/null || echo '{}'",
            returnStdout: true
        ).trim()

        if (response.contains(expectedCommit) || response.contains(expectedCommit.take(7))) {
            return [match: true, response: response]
        }
        return [match: false, response: response, expected: expectedCommit]
    } catch (Exception e) {
        return [match: false, error: e.message]
    }
}

/**
 * Get health status of an endpoint
 */
def checkHealth(String name, String url) {
    def status = sh(
        script: "curl -sf -o /dev/null -w '%{http_code}' '${url}' 2>/dev/null || echo '000'",
        returnStdout: true
    ).trim()
    return [name: name, url: url, status: status, healthy: status in ['200', '301', '302']]
}

/**
 * Order pipelines by dependencies using topological sort
 */
def orderByDependencies(pipelineList) {
    def ordered = []
    def remaining = pipelineList.collect()

    while (!remaining.isEmpty()) {
        def ready = remaining.find { name ->
            def deps = PIPELINES[name].dependsOn ?: []
            deps.every { dep ->
                !remaining.contains(dep) || ordered.contains(dep)
            }
        }

        if (ready) {
            ordered.add(ready)
            remaining.remove(ready)
        } else {
            ordered.addAll(remaining)
            break
        }
    }

    return ordered
}

/**
 * Trigger a pipeline and wait for result
 */
def triggerPipeline(String name, String branch, boolean wait = true) {
    echo "‚ñ∂Ô∏è Triggering ${name}/${branch}..."

    try {
        def result = build(
            job: "${name}/${branch}",
            wait: wait,
            propagate: false,
            parameters: [
                booleanParam(name: 'FORCE_BUILD', value: true),
                booleanParam(name: 'FORCE_DEPLOY', value: true)
            ]
        )

        return [
            success: result.result == 'SUCCESS',
            result: result.result,
            duration: result.duration,
            url: result.absoluteUrl
        ]
    } catch (Exception e) {
        return [
            success: false,
            result: 'ERROR',
            error: e.message
        ]
    }
}

/**
 * Print a decision matrix showing what will be built and why
 */
def printDecisionMatrix(analysis, pipelines) {
    echo '''
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                          DEPLOYMENT DECISION MATRIX                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£'''

    PIPELINES.each { name, config ->
        def info = analysis[name]
        def willRun = pipelines.contains(name)
        def icon = willRun ? 'üî®' : (info.manualOnly ? 'üîí' : '‚è≠Ô∏è')
        def status = willRun ? 'BUILD' : (info.manualOnly ? 'MANUAL' : 'SKIP')

        echo "‚ïë ${icon} ${name.padRight(20)} ‚îÇ ${status.padRight(8)} ‚îÇ ${info.matchedPatterns.join(', ') ?: 'no changes'}"

        if (info.sampleFiles && info.sampleFiles.size() > 0) {
            info.sampleFiles.each { file ->
                echo "‚ïë    ‚îî‚îÄ ${file}"
            }
        }
    }

    echo '''‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'''
}

/**
 * Print deployment verification results
 */
def printDeploymentVerification(commit, results) {
    echo """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                          DEPLOYMENT VERIFICATION                              ‚ïë
‚ïë  Expected commit: ${commit}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"""

    results.each { name, result ->
        def icon = result.match ? '‚úÖ' : '‚ùå'
        def status = result.match ? 'VERIFIED' : 'MISMATCH'
        echo "‚ïë ${icon} ${name.padRight(20)} ‚îÇ ${status}"
        if (!result.match && result.response) {
            echo "‚ïë    ‚îî‚îÄ Got: ${result.response.take(60)}..."
        }
    }

    echo '''‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'''
}

// =============================================================================
// PIPELINE
// =============================================================================

pipeline {
    agent {
        kubernetes {
            cloud 'kubernetes'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  serviceAccount: jenkins-deployer
  nodeSelector:
    node-type: edge
  containers:
  - name: builder
    image: harbor.ethosengine.com/ethosengine/ci-builder:latest
    command: [cat]
    tty: true
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
'''
        }
    }

    environment {
        BRANCH_NAME = "${env.BRANCH_NAME ?: 'dev'}"
    }

    parameters {
        choice(
            name: 'MODE',
            choices: ['auto', 'status', 'rebuild-all', 'rebuild-edge', 'rebuild-app', 'genesis-only'],
            description: '''
                auto = Analyze changes and build what's needed
                status = Report deployment status only (no builds)
                rebuild-all = Force rebuild everything
                rebuild-edge = Force rebuild edge infrastructure (doorway, storage, conductor)
                rebuild-app = Force rebuild Angular app only
                genesis-only = Run seed + test without rebuilding
            '''
        )
        booleanParam(
            name: 'SKIP_GENESIS',
            defaultValue: false,
            description: 'Skip seed+test after builds (useful for infrastructure-only changes)'
        )
        booleanParam(
            name: 'VERIFY_DEPLOYMENT',
            defaultValue: true,
            description: 'Verify deployed versions match built versions after deployment'
        )
        string(
            name: 'FORCE_COMMIT',
            defaultValue: '',
            description: 'Force analysis from a specific commit (leave empty for auto-detect)'
        )
    }

    triggers {
        githubPush()
    }

    options {
        timeout(time: 120, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '100'))
    }

    stages {
        stage('Checkout') {
            steps {
                container('builder') {
                    script {
                        sh 'git config --global --add safe.directory "*"'

                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${env.BRANCH_NAME}"]],
                            extensions: [
                                [$class: 'CloneOption', shallow: false, noTags: true, depth: 50],
                                [$class: 'CleanBeforeCheckout']
                            ],
                            userRemoteConfigs: [[
                                url: 'https://github.com/ethosengine/elohim.git',
                                credentialsId: 'ee-bot-pat'
                            ]]
                        ])

                        env.GIT_COMMIT_SHORT = getGitCommitHash()
                        env.GIT_COMMIT_FULL = getGitCommitHashFull()

                        echo """
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        üé≠ ELOHIM ORCHESTRATOR v2
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  Branch:  ${env.BRANCH_NAME}
  Commit:  ${env.GIT_COMMIT_SHORT} (${env.GIT_COMMIT_FULL})
  Mode:    ${params.MODE}
  Build:   #${env.BUILD_NUMBER}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        """
                    }
                }
            }
        }

        stage('Pre-flight Health Check') {
            steps {
                container('builder') {
                    script {
                        echo '''
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                           PRE-FLIGHT HEALTH CHECK                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò'''

                        def healthResults = [:]
                        HEALTH_ENDPOINTS.each { name, url ->
                            def result = checkHealth(name, url)
                            healthResults[name] = result
                            echo "${result.healthy ? '‚úÖ' : '‚ùå'} ${name}: HTTP ${result.status} - ${url}"
                        }

                        env.PREFLIGHT_HEALTH = writeJSON(returnText: true, json: healthResults)

                        def unhealthy = healthResults.findAll { k, v -> !v.healthy }
                        if (unhealthy.size() > 0) {
                            echo "‚ö†Ô∏è  WARNING: ${unhealthy.size()} service(s) unhealthy before deployment"
                        }
                    }
                }
            }
        }

        stage('Analyze Changes') {
            when {
                expression { params.MODE in ['auto', 'status'] }
            }
            steps {
                container('builder') {
                    script {
                        def changedFiles = analyzeChangeset()
                        def analysis = analyzePipelineRequirements(changedFiles)

                        env.CHANGED_FILES_COUNT = changedFiles.size().toString()
                        env.ANALYSIS_JSON = writeJSON(returnText: true, json: analysis)

                        echo """
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              CHANGESET ANALYSIS                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Total changed files: ${changedFiles.size()}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"""

                        // Show changed files grouped by area
                        def filesByArea = [:]
                        changedFiles.each { file ->
                            def area = file.split('/')[0]
                            if (!filesByArea[area]) filesByArea[area] = []
                            filesByArea[area].add(file)
                        }

                        filesByArea.each { area, files ->
                            echo "üìÅ ${area}/ (${files.size()} files)"
                            files.take(5).each { echo "   ‚îî‚îÄ ${it}" }
                            if (files.size() > 5) echo "   ‚îî‚îÄ ... and ${files.size() - 5} more"
                        }

                        // Determine pipelines to run
                        def toRun = analysis.findAll { name, info -> info.shouldRun }.keySet().toList()
                        def ordered = orderByDependencies(toRun)

                        env.PIPELINES_TO_RUN = ordered.join(',')

                        printDecisionMatrix(analysis, ordered)

                        if (ordered.isEmpty() && params.MODE == 'auto') {
                            echo '‚ÑπÔ∏è  No pipelines need to run for these changes'
                            currentBuild.description = "No builds needed (${changedFiles.size()} files)"
                        } else {
                            currentBuild.description = "Building: ${ordered.join(', ')}"
                        }
                    }
                }
            }
        }

        stage('Determine Build Plan') {
            when {
                expression { params.MODE in ['rebuild-all', 'rebuild-edge', 'rebuild-app', 'genesis-only'] }
            }
            steps {
                container('builder') {
                    script {
                        def pipelines = []

                        switch (params.MODE) {
                            case 'rebuild-all':
                                pipelines = ['elohim-holochain', 'elohim-edge', 'elohim']
                                if (!params.SKIP_GENESIS) pipelines.add('elohim-genesis')
                                break
                            case 'rebuild-edge':
                                pipelines = ['elohim-edge']
                                if (!params.SKIP_GENESIS) pipelines.add('elohim-genesis')
                                break
                            case 'rebuild-app':
                                pipelines = ['elohim']
                                if (!params.SKIP_GENESIS) pipelines.add('elohim-genesis')
                                break
                            case 'genesis-only':
                                pipelines = ['elohim-genesis']
                                break
                        }

                        env.PIPELINES_TO_RUN = pipelines.join(',')

                        echo """
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              FORCED BUILD PLAN                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Mode: ${params.MODE}
‚îÇ  Pipelines: ${pipelines.join(' ‚Üí ')}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"""

                        currentBuild.description = "${params.MODE}: ${pipelines.join(', ')}"
                    }
                }
            }
        }

        stage('Execute Builds') {
            when {
                expression {
                    params.MODE != 'status' && (env.PIPELINES_TO_RUN ?: '') != ''
                }
            }
            steps {
                container('builder') {
                    script {
                        def pipelines = (env.PIPELINES_TO_RUN ?: '').split(',').findAll { it }
                        def results = [:]

                        if (pipelines.isEmpty()) {
                            echo '‚ÑπÔ∏è  No pipelines to execute'
                            return
                        }

                        echo """
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              EXECUTING BUILDS                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Order: ${pipelines.join(' ‚Üí ')}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"""

                        // Execute in dependency order
                        pipelines.each { name ->
                            if (name == 'elohim-genesis') {
                                // Genesis runs after all others, skip for now
                                return
                            }

                            echo ''
                            echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'
                            echo "üî® Building: ${name}"
                            echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'

                            def result = triggerPipeline(name, env.BRANCH_NAME, true)
                            results[name] = result

                            if (result.success) {
                                echo "‚úÖ ${name}: SUCCESS (${result.duration / 1000}s)"
                            } else {
                                echo "‚ùå ${name}: ${result.result}"
                                if (result.error) echo "   Error: ${result.error}"
                            }
                        }

                        env.BUILD_RESULTS = writeJSON(returnText: true, json: results)

                        // Check if all succeeded before genesis
                        def allSucceeded = results.every { k, v -> v.success }

                        if (!allSucceeded) {
                            def failed = results.findAll { k, v -> !v.success }.keySet()
                            error "Build(s) failed: ${failed.join(', ')} - Aborting genesis"
                        }

                        // Run genesis if requested
                        if (pipelines.contains('elohim-genesis')) {
                            echo ''
                            echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'
                            echo 'üå± Running Genesis (seed + test)'
                            echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'

                            def genesisResult = triggerPipeline('elohim-genesis', env.BRANCH_NAME, true)
                            results['elohim-genesis'] = genesisResult

                            if (genesisResult.success) {
                                echo '‚úÖ elohim-genesis: SUCCESS'
                            } else {
                                echo "‚ùå elohim-genesis: ${genesisResult.result}"
                                unstable('Genesis failed - seeding or tests may have issues')
                            }

                            env.BUILD_RESULTS = writeJSON(returnText: true, json: results)
                        }
                    }
                }
            }
        }

        stage('Verify Deployment') {
            when {
                expression {
                    params.VERIFY_DEPLOYMENT && params.MODE != 'status' && (env.PIPELINES_TO_RUN ?: '') != ''
                }
            }
            steps {
                container('builder') {
                    script {
                        echo '''
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          POST-DEPLOYMENT VERIFICATION                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò'''

                        // Wait for deployments to stabilize
                        echo '‚è≥ Waiting 30s for deployments to stabilize...'
                        sleep(30)

                        def verificationResults = [:]

                        VERSION_ENDPOINTS.each { name, url ->
                            def result = checkDeployedVersion(url, env.GIT_COMMIT_SHORT)
                            verificationResults[name] = result
                        }

                        printDeploymentVerification(env.GIT_COMMIT_SHORT, verificationResults)

                        env.VERIFICATION_RESULTS = writeJSON(returnText: true, json: verificationResults)

                        def mismatches = verificationResults.findAll { k, v -> !v.match }
                        if (mismatches.size() > 0) {
                            echo "‚ö†Ô∏è  WARNING: ${mismatches.size()} deployment(s) may not have the expected version"
                            echo '   This could mean:'
                            echo '   - Deployment is still rolling out'
                            echo '   - Version endpoint not implemented'
                            echo '   - Deployment failed silently'
                        }
                    }
                }
            }
        }

        stage('Post-flight Health Check') {
            steps {
                container('builder') {
                    script {
                        echo '''
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          POST-FLIGHT HEALTH CHECK                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò'''

                        def healthResults = [:]
                        HEALTH_ENDPOINTS.each { name, url ->
                            def result = checkHealth(name, url)
                            healthResults[name] = result
                            echo "${result.healthy ? '‚úÖ' : '‚ùå'} ${name}: HTTP ${result.status}"
                        }

                        env.POSTFLIGHT_HEALTH = writeJSON(returnText: true, json: healthResults)

                        def unhealthy = healthResults.findAll { k, v -> !v.healthy }
                        if (unhealthy.size() > 0) {
                            unstable("${unhealthy.size()} service(s) unhealthy after deployment")
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            container('builder') {
                script {
                    def results = readJSON(text: env.BUILD_RESULTS ?: '{}')
                    def preflight = readJSON(text: env.PREFLIGHT_HEALTH ?: '{}')
                    def postflight = readJSON(text: env.POSTFLIGHT_HEALTH ?: '{}')
                    def verification = readJSON(text: env.VERIFICATION_RESULTS ?: '{}')

                    def successCount = results.count { k, v -> v?.success }
                    def failCount = results.count { k, v -> !v?.success }
                    def healthyCount = postflight.count { k, v -> v?.healthy }
                    def verifiedCount = verification.count { k, v -> v?.match }

                    echo """
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                              üìä ORCHESTRATOR SUMMARY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  Commit:       ${env.GIT_COMMIT_SHORT}
  Branch:       ${env.BRANCH_NAME}
  Mode:         ${params.MODE}

  BUILDS:       ‚úÖ ${successCount} succeeded ‚îÇ ‚ùå ${failCount} failed
  SERVICES:     ${healthyCount}/${postflight.size()} healthy
  VERIFIED:     ${verifiedCount}/${verification.size()} deployments match commit

${failCount > 0 ? '  ‚ö†Ô∏è  ATTENTION: Build failures detected!' : '  ‚úÖ All builds completed successfully'}
${healthyCount < postflight.size() ? '  ‚ö†Ô∏è  ATTENTION: Some services unhealthy!' : ''}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    """

                    if (failCount > 0) {
                        echo 'Failed pipelines:'
                        results.findAll { k, v -> !v?.success }.each { name, result ->
                            echo "  ‚ùå ${name}: ${result?.result ?: 'UNKNOWN'}"
                            if (result?.url) echo "     ${result.url}"
                    }
                }

                    // Generate machine-readable CI summary for Claude consumption
                    def unhealthyCount = postflight.count { k, v -> !v?.healthy }
                    def ciSummary = [
                        schema_version: '1.0.0',
                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC')),
                        orchestration: [
                            build_number: env.BUILD_NUMBER,
                            build_url: env.BUILD_URL,
                            branch: env.BRANCH_NAME,
                            commit: env.GIT_COMMIT_SHORT ?: 'unknown',
                            mode: params.MODE,
                            duration_seconds: (System.currentTimeMillis() - currentBuild.startTimeInMillis) / 1000
                        ],
                        pipelines: results.collect { name, r ->
                            [
                                name: name,
                                status: r?.success ? 'SUCCESS' : (r?.result ?: 'FAILURE'),
                                url: r?.url,
                                duration_ms: r?.duration,
                                category: r?.success ? null : categorizeFailure(name),
                                remediation_hint: r?.success ? null : getRemediationHint(name)
                            ]
                        },
                        health: [
                            preflight: preflight,
                            postflight: postflight,
                            degraded_services: postflight.findAll { k, v -> !v?.healthy }.keySet().toList()
                        ],
                        deployment: [
                            verified: verification.every { k, v -> v?.match },
                            verification_results: verification,
                            mismatches: verification.findAll { k, v -> !v?.match }.keySet().toList()
                        ],
                        summary: [
                            overall_status: failCount > 0 ? 'FAILURE' : (unhealthyCount > 0 ? 'UNSTABLE' : 'SUCCESS'),
                            builds_succeeded: successCount,
                            builds_failed: failCount,
                            services_healthy: healthyCount,
                            services_total: postflight.size(),
                            failed_pipelines: results.findAll { k, v -> !v?.success }.keySet().toList(),
                            triage_priority: calculateTriagePriority(failCount, unhealthyCount),
                            action_required: failCount > 0 ? results.findAll { k, v -> !v?.success }.collect { name, r ->
                                "${name}: ${getRemediationHint(name)}"
                            } : []
                        ]
                    ]

                    writeJSON file: 'ci-summary.json', json: ciSummary, pretty: 2
                    archiveArtifacts artifacts: 'ci-summary.json', allowEmptyArchive: false
                    echo "üìã CI Summary archived: ${env.BUILD_URL}artifact/ci-summary.json"
        }
    }
}
    }
}
