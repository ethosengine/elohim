/**
 * Elohim Orchestrator Pipeline
 *
 * CENTRAL CONTROLLER for all Elohim mono-repo pipelines.
 * This is the ONLY pipeline that receives GitHub webhooks.
 * All other pipelines are manual-only and triggered by this orchestrator.
 *
 * Architecture:
 *   GitHub Webhook â†’ Orchestrator â†’ Analyze â†’ Trigger Pipelines â†’ Report
 *                                      â†“
 *                              (optional) Claude Agent webhook
 *                                   for complex decisions
 *
 * Responsibilities:
 *   1. Receive all GitHub push webhooks
 *   2. Analyze changesets to determine what needs to build
 *   3. Trigger pipelines in dependency order
 *   4. Wait for dependencies before triggering consumers
 *   5. Report status and trigger Claude agent for issues
 *
 * Dependency Graph:
 *   elohim-holochain (DNA/hApp, WASM)
 *       â”œâ”€â”€â–º elohim-edge (infrastructure) â”€â”€â”
 *       â”œâ”€â”€â–º elohim (Angular app) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â–º elohim-genesis (seed + test)
 *       â””â”€â”€â–º elohim-steward (manual only)   â”‚
 *                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
 */

// =============================================================================
// CONFIGURATION
// =============================================================================

import groovy.transform.Field

@Field def PIPELINES = [
    'elohim-holochain': [
        jenkinsPath: 'holochain/dna/Jenkinsfile',
        changePatterns: ['holochain/dna/', 'holochain/holochain-cache-core/'],
        artifacts: ['elohim.happ', 'holochain-cache-core/pkg'],
        dependsOn: [],
        triggersGenesis: true
    ],
    'elohim-edge': [
        jenkinsPath: 'holochain/Jenkinsfile',
        changePatterns: ['holochain/doorway/', 'holochain/edgenode/', 'holochain/manifests/'],
        artifacts: ['elohim-doorway', 'elohim-edgenode', 'elohim-happ-installer'],
        dependsOn: ['elohim-holochain'],
        triggersGenesis: true
    ],
    'elohim': [
        jenkinsPath: 'Jenkinsfile',
        changePatterns: ['elohim-app/', 'elohim-library/', 'VERSION'],
        artifacts: ['elohim-app'],
        dependsOn: ['elohim-holochain'],
        triggersGenesis: true,
        // DISABLED: Root Jenkinsfile causes "Method too large" error (1330 lines).
        // The pipeline needs refactoring into shared library before re-enabling.
        // For now, trigger manually or wait for refactor.
        manualOnly: true
    ],
    'elohim-genesis': [
        jenkinsPath: 'genesis/Jenkinsfile',
        changePatterns: ['genesis/'],
        artifacts: [],
        dependsOn: ['elohim-holochain', 'elohim-edge', 'elohim'],
        triggersGenesis: false
    ],
    'elohim-steward': [
        jenkinsPath: 'steward/Jenkinsfile',
        changePatterns: ['steward/'],
        artifacts: ['steward-desktop'],
        dependsOn: ['elohim-holochain'],
        manualOnly: true,
        triggersGenesis: false
    ]
]

@Field def HEALTH_ENDPOINTS = [
    'doorway-dev': 'https://doorway-dev.elohim.host/health',
    'doorway-prod': 'https://doorway.elohim.host/health',
    'alpha': 'https://alpha.elohim.host',
    'staging': 'https://staging.elohim.host',
    'prod': 'https://elohim.host'
]

// Claude agent webhook for complex decisions (optional)
@Field def CLAUDE_AGENT_WEBHOOK = ''

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

def analyzeChangeset() {
    // Get changed files from the push
    def changedFiles = sh(
        script: '''
            git diff --name-only HEAD~1 2>/dev/null || git diff --name-only HEAD
        ''',
        returnStdout: true
    ).trim().split('\n').findAll { it }

    echo "Changed files: ${changedFiles.size()}"
    changedFiles.each { echo "  - ${it}" }

    return changedFiles
}

def determinePipelinesToRun(changedFiles) {
    def toRun = []

    PIPELINES.each { name, config ->
        if (config.manualOnly) {
            echo "â­ï¸ ${name}: manual-only, skipping"
            return
        }

        def matches = changedFiles.any { file ->
            config.changePatterns.any { pattern ->
                file.startsWith(pattern)
            }
        }

        if (matches) {
            toRun.add(name)
            echo "âœ… ${name}: changes detected"
        } else {
            echo "â­ï¸ ${name}: no matching changes"
        }
    }

    return toRun
}

def orderByDependencies(pipelineList) {
    // Topological sort based on dependencies
    def ordered = []
    def remaining = pipelineList.collect()

    while (!remaining.isEmpty()) {
        def ready = remaining.find { name ->
            def deps = PIPELINES[name].dependsOn ?: []
            // Ready if all dependencies are either not in the list or already ordered
            deps.every { dep ->
                !remaining.contains(dep) || ordered.contains(dep)
            }
        }

        if (ready) {
            ordered.add(ready)
            remaining.remove(ready)
        } else {
            // Circular dependency or missing - just add remaining
            ordered.addAll(remaining)
            break
        }
    }

    return ordered
}

def triggerPipeline(String name, String branch, boolean wait = true) {
    echo "â–¶ï¸ Triggering ${name}/${branch} with FORCE_BUILD=true..."

    try {
        def result = build(
            job: "${name}/${branch}",
            wait: wait,
            propagate: false,
            parameters: [
                booleanParam(name: 'FORCE_BUILD', value: true),
                booleanParam(name: 'FORCE_DEPLOY', value: true)
            ]
        )

        if (result.result == 'SUCCESS') {
            echo "âœ… ${name}: SUCCESS"
            return true
        } else {
            echo "âŒ ${name}: ${result.result}"
            return false
        }
    } catch (Exception e) {
        echo "âŒ ${name}: Failed to trigger - ${e.message}"
        return false
    }
}

def checkHealth(String name, String url) {
    def status = sh(
        script: "curl -sf -o /dev/null -w '%{http_code}' '${url}' 2>/dev/null || echo '000'",
        returnStdout: true
    ).trim()
    return [name: name, url: url, status: status, healthy: status in ['200', '301', '302']]
}

def notifyClaudeAgent(Map context) {
    def webhookUrl = env.CLAUDE_AGENT_WEBHOOK ?: CLAUDE_AGENT_WEBHOOK
    if (!webhookUrl) {
        echo "Claude agent webhook not configured"
        return
    }

    def payload = writeJSON(returnText: true, json: context)

    try {
        sh """
            curl -sf -X POST '${webhookUrl}' \
                -H 'Content-Type: application/json' \
                -d '${payload}'
        """
        echo "ğŸ“¤ Notified Claude agent"
    } catch (Exception e) {
        echo "âš ï¸ Failed to notify Claude agent: ${e.message}"
    }
}

// =============================================================================
// PIPELINE
// =============================================================================

pipeline {
    agent {
        kubernetes {
            cloud 'kubernetes'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  serviceAccount: jenkins-deployer
  nodeSelector:
    node-type: edge
  containers:
  - name: builder
    image: harbor.ethosengine.com/ethosengine/ci-builder:latest
    command: [cat]
    tty: true
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
'''
        }
    }

    environment {
        BRANCH_NAME = "${env.BRANCH_NAME ?: 'dev'}"
    }

    parameters {
        choice(
            name: 'MODE',
            choices: ['auto', 'status', 'trigger-all', 'trigger-specific'],
            description: 'auto=analyze and trigger, status=report only, trigger-all=force all, trigger-specific=specific pipeline'
        )
        string(
            name: 'SPECIFIC_PIPELINE',
            defaultValue: '',
            description: 'Pipeline to trigger (for trigger-specific mode)'
        )
        booleanParam(
            name: 'SKIP_GENESIS',
            defaultValue: false,
            description: 'Skip triggering genesis after builds complete'
        )
        booleanParam(
            name: 'NOTIFY_CLAUDE',
            defaultValue: false,
            description: 'Send results to Claude agent webhook for analysis'
        )
    }

    triggers {
        // This is the ONLY pipeline that receives GitHub webhooks
        githubPush()
    }

    options {
        timeout(time: 120, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '100'))
    }

    stages {
        stage('Checkout') {
            steps {
                container('builder') {
                    script {
                        sh 'git config --global --add safe.directory "*"'

                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${env.BRANCH_NAME}"]],
                            extensions: [
                                [$class: 'CloneOption', shallow: false, noTags: true],
                                [$class: 'CleanBeforeCheckout']
                            ],
                            userRemoteConfigs: [[
                                url: 'https://github.com/ethosengine/elohim.git',
                                credentialsId: 'ee-bot-pat'
                            ]]
                        ])

                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ğŸ­ ELOHIM ORCHESTRATOR
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        Branch: ${env.BRANCH_NAME}
                        Mode: ${params.MODE}
                        Build: ${env.BUILD_NUMBER}
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """
                    }
                }
            }
        }

        stage('Analyze Changes') {
            when {
                expression { params.MODE == 'auto' || params.MODE == 'status' }
            }
            steps {
                container('builder') {
                    script {
                        def changedFiles = analyzeChangeset()
                        def pipelinesToRun = determinePipelinesToRun(changedFiles)
                        def orderedPipelines = orderByDependencies(pipelinesToRun)

                        env.PIPELINES_TO_RUN = orderedPipelines.join(',')
                        env.CHANGED_FILES_COUNT = changedFiles.size().toString()

                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ ANALYSIS RESULTS                                        â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        â”‚ Changed files: ${changedFiles.size()}
                        â”‚ Pipelines to run: ${orderedPipelines.size()}
                        â”‚ Order: ${orderedPipelines.join(' â†’ ')}
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """

                        if (orderedPipelines.isEmpty() && params.MODE == 'auto') {
                            echo "No pipelines need to run for these changes"
                            currentBuild.description = "No changes requiring builds"
                        }
                    }
                }
            }
        }

        stage('Trigger Pipelines') {
            when {
                expression {
                    params.MODE == 'auto' || params.MODE == 'trigger-all' || params.MODE == 'trigger-specific'
                }
            }
            steps {
                container('builder') {
                    script {
                        def pipelines = []
                        def results = [:]

                        if (params.MODE == 'trigger-specific' && params.SPECIFIC_PIPELINE) {
                            pipelines = [params.SPECIFIC_PIPELINE]
                        } else if (params.MODE == 'trigger-all') {
                            pipelines = PIPELINES.findAll { name, config -> !config.manualOnly }.keySet().toList()
                            pipelines = orderByDependencies(pipelines)
                        } else {
                            pipelines = (env.PIPELINES_TO_RUN ?: '').split(',').findAll { it }
                        }

                        if (pipelines.isEmpty()) {
                            echo "No pipelines to trigger"
                            return
                        }

                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ TRIGGERING PIPELINES                                    â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        â”‚ Order: ${pipelines.join(' â†’ ')}
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """

                        // Group by dependency level for parallel execution
                        def level0 = pipelines.findAll { name ->
                            def deps = PIPELINES[name]?.dependsOn ?: []
                            deps.every { !pipelines.contains(it) }
                        }
                        def remaining = pipelines - level0

                        // Trigger level 0 (no dependencies in this run)
                        if (level0) {
                            echo "Level 0 (parallel): ${level0.join(', ')}"
                            def parallelBuilds = [:]
                            level0.each { name ->
                                parallelBuilds[name] = {
                                    results[name] = triggerPipeline(name, env.BRANCH_NAME, true)
                                }
                            }
                            parallel parallelBuilds
                        }

                        // Trigger remaining in order
                        remaining.each { name ->
                            results[name] = triggerPipeline(name, env.BRANCH_NAME, true)
                        }

                        // Check if we should trigger genesis
                        def shouldTriggerGenesis = !params.SKIP_GENESIS &&
                            pipelines.any { PIPELINES[it]?.triggersGenesis } &&
                            results.every { k, v -> v }

                        if (shouldTriggerGenesis && !pipelines.contains('elohim-genesis')) {
                            echo "All builds succeeded, triggering genesis..."
                            results['elohim-genesis'] = triggerPipeline('elohim-genesis', env.BRANCH_NAME, true)
                        }

                        // Store results
                        env.BUILD_RESULTS = writeJSON(returnText: true, json: results)

                        // Summary
                        def successCount = results.count { k, v -> v }
                        def failCount = results.count { k, v -> !v }

                        currentBuild.description = "âœ… ${successCount} | âŒ ${failCount}"

                        if (failCount > 0) {
                            unstable("${failCount} pipeline(s) failed")
                        }
                    }
                }
            }
        }

        stage('Health Check') {
            steps {
                container('builder') {
                    script {
                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ SERVICE HEALTH                                          â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        """

                        def healthResults = [:]
                        HEALTH_ENDPOINTS.each { name, url ->
                            def result = checkHealth(name, url)
                            healthResults[name] = result
                            echo "â”‚ ${result.healthy ? 'âœ…' : 'âŒ'} ${name}: HTTP ${result.status}"
                        }

                        echo """
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """

                        env.HEALTH_RESULTS = writeJSON(returnText: true, json: healthResults)
                    }
                }
            }
        }

        stage('Notify Claude Agent') {
            when {
                expression { params.NOTIFY_CLAUDE || currentBuild.result == 'UNSTABLE' }
            }
            steps {
                container('builder') {
                    script {
                        def context = [
                            event: 'orchestrator_complete',
                            branch: env.BRANCH_NAME,
                            build: env.BUILD_NUMBER,
                            mode: params.MODE,
                            changedFilesCount: env.CHANGED_FILES_COUNT?.toInteger() ?: 0,
                            pipelinesTriggered: (env.PIPELINES_TO_RUN ?: '').split(',').findAll { it },
                            buildResults: readJSON(text: env.BUILD_RESULTS ?: '{}'),
                            healthResults: readJSON(text: env.HEALTH_RESULTS ?: '{}'),
                            result: currentBuild.result ?: 'SUCCESS',
                            url: env.BUILD_URL
                        ]

                        if (currentBuild.result == 'UNSTABLE') {
                            context.alert = 'Pipeline failures detected - review required'
                        }

                        notifyClaudeAgent(context)
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def results = readJSON(text: env.BUILD_RESULTS ?: '{}')
                def health = readJSON(text: env.HEALTH_RESULTS ?: '{}')

                def successCount = results.count { k, v -> v }
                def failCount = results.count { k, v -> !v }
                def healthyCount = health.count { k, v -> v?.healthy }

                echo """
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                ğŸ“Š ORCHESTRATOR SUMMARY
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                Branch: ${env.BRANCH_NAME}
                Pipelines: âœ… ${successCount} succeeded, âŒ ${failCount} failed
                Services: ${healthyCount}/${health.size()} healthy

                ${failCount > 0 ? 'âš ï¸ Review failed pipelines above' : 'âœ… All systems nominal'}
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
            }
        }
        failure {
            script {
                if (env.CLAUDE_AGENT_WEBHOOK || CLAUDE_AGENT_WEBHOOK) {
                    notifyClaudeAgent([
                        event: 'orchestrator_failed',
                        branch: env.BRANCH_NAME,
                        build: env.BUILD_NUMBER,
                        url: env.BUILD_URL,
                        alert: 'Orchestrator pipeline itself failed - immediate attention required'
                    ])
                }
            }
        }
    }
}
