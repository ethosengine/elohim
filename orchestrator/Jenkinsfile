/**
 * Elohim Orchestrator Pipeline
 *
 * Observability and coordination for the Elohim mono-repo pipelines.
 * Does NOT build anything - only monitors, reports, and recommends actions.
 *
 * Responsibilities:
 *   - Track artifact versions across all pipelines
 *   - Detect version drift and stale dependencies
 *   - Monitor health of deployed services
 *   - Generate actionable recommendations
 *
 * Triggers:
 *   - Cron: Every 15 minutes
 *   - Manual: On-demand status check
 *   - Upstream: After any pipeline completes (optional)
 */

// Pipeline artifact sources
def PIPELINES = [
    'elohim-holochain': [
        path: 'holochain/dna/Jenkinsfile',
        artifacts: ['elohim.happ', 'holochain-cache-core'],
        consumers: ['elohim-edge', 'elohim', 'elohim-steward', 'elohim-genesis']
    ],
    'elohim-edge': [
        path: 'holochain/Jenkinsfile',
        artifacts: ['elohim-doorway', 'elohim-edgenode', 'elohim-happ-installer'],
        consumers: ['elohim-genesis'],
        depends: ['elohim-holochain']
    ],
    'elohim': [
        path: 'Jenkinsfile',
        artifacts: ['elohim-app'],
        consumers: ['elohim-genesis'],
        depends: ['elohim-holochain']
    ],
    'elohim-genesis': [
        path: 'genesis/Jenkinsfile',
        artifacts: [],
        consumers: [],
        depends: ['elohim-holochain', 'elohim-edge', 'elohim']
    ],
    'elohim-steward': [
        path: 'steward/Jenkinsfile',
        artifacts: ['steward-linux', 'steward-macos', 'steward-windows'],
        consumers: [],
        depends: ['elohim-holochain'],
        manualOnly: true
    ]
]

// Service health endpoints
def HEALTH_ENDPOINTS = [
    'doorway-dev': 'https://doorway-dev.elohim.host/health',
    'doorway-prod': 'https://doorway.elohim.host/health',
    'alpha': 'https://alpha.elohim.host',
    'staging': 'https://staging.elohim.host',
    'prod': 'https://elohim.host'
]

def getLastSuccessfulBuild(String jobName, String branch) {
    def url = "https://jenkins.ethosengine.com/job/${jobName}/job/${branch}/lastSuccessfulBuild/api/json"
    try {
        def response = sh(
            script: "curl -sf '${url}' 2>/dev/null || echo '{}'",
            returnStdout: true
        ).trim()
        return readJSON(text: response)
    } catch (Exception e) {
        return [:]
    }
}

def checkHealth(String name, String url) {
    def status = sh(
        script: "curl -sf -o /dev/null -w '%{http_code}' '${url}' 2>/dev/null || echo '000'",
        returnStdout: true
    ).trim()
    return [
        name: name,
        url: url,
        status: status,
        healthy: status == '200' || status == '302' || status == '301'
    ]
}

def getArtifactVersion(String jobName, String branch, String artifactPath) {
    def url = "https://jenkins.ethosengine.com/job/${jobName}/job/${branch}/lastSuccessfulBuild/artifact/${artifactPath}"
    def exists = sh(
        script: "curl -sf -o /dev/null '${url}' 2>/dev/null && echo 'true' || echo 'false'",
        returnStdout: true
    ).trim()
    return exists == 'true'
}

pipeline {
    agent {
        kubernetes {
            cloud 'kubernetes'
            yaml '''
apiVersion: v1
kind: Pod
spec:
  serviceAccount: jenkins-deployer
  nodeSelector:
    node-type: edge
  containers:
  - name: builder
    image: harbor.ethosengine.com/ethosengine/ci-builder:latest
    command: [cat]
    tty: true
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
'''
        }
    }

    parameters {
        booleanParam(
            name: 'FULL_REPORT',
            defaultValue: true,
            description: 'Generate full status report'
        )
        booleanParam(
            name: 'CHECK_HEALTH',
            defaultValue: true,
            description: 'Check health of all endpoints'
        )
        string(
            name: 'BRANCH',
            defaultValue: 'dev',
            description: 'Branch to check artifact versions for'
        )
    }

    triggers {
        // Run every 15 minutes during work hours
        cron('H/15 8-20 * * 1-5')
    }

    options {
        timeout(time: 10, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '50'))
    }

    stages {
        stage('Collect Pipeline Status') {
            steps {
                container('builder') {
                    script {
                        def branch = params.BRANCH ?: 'dev'
                        def pipelineStatus = [:]

                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ğŸ“Š ELOHIM ORCHESTRATOR - PIPELINE STATUS
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        Branch: ${branch}
                        Timestamp: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """

                        PIPELINES.each { name, config ->
                            def buildInfo = getLastSuccessfulBuild(name, branch)
                            def status = [
                                name: name,
                                lastBuild: buildInfo.number ?: 'N/A',
                                lastSuccess: buildInfo.timestamp ? new Date(buildInfo.timestamp).format('yyyy-MM-dd HH:mm') : 'Never',
                                duration: buildInfo.duration ? "${(buildInfo.duration / 1000 / 60).round(1)} min" : 'N/A',
                                result: buildInfo.result ?: 'UNKNOWN',
                                manualOnly: config.manualOnly ?: false
                            ]
                            pipelineStatus[name] = status
                        }

                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ PIPELINE BUILDS                                         â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        """

                        pipelineStatus.each { name, status ->
                            def icon = status.result == 'SUCCESS' ? 'âœ…' : (status.result == 'FAILURE' ? 'âŒ' : 'âš ï¸')
                            def manual = status.manualOnly ? ' [MANUAL]' : ''
                            echo "â”‚ ${icon} ${name}${manual}"
                            echo "â”‚    Build #${status.lastBuild} | ${status.lastSuccess} | ${status.duration}"
                        }

                        echo """
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """

                        // Store for later stages
                        env.PIPELINE_STATUS = writeJSON(returnText: true, json: pipelineStatus)
                    }
                }
            }
        }

        stage('Check Artifact Versions') {
            when {
                expression { params.FULL_REPORT }
            }
            steps {
                container('builder') {
                    script {
                        def branch = params.BRANCH ?: 'dev'

                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ ARTIFACT INVENTORY                                      â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        """

                        // Check elohim-holochain artifacts
                        def happExists = getArtifactVersion('elohim-holochain', branch, 'holochain/dna/elohim/elohim.happ')
                        def wasmExists = getArtifactVersion('elohim-holochain', branch, 'holochain/holochain-cache-core/pkg/holochain_cache_core.js')

                        echo "â”‚ elohim-holochain:"
                        echo "â”‚   ${happExists ? 'âœ…' : 'âŒ'} elohim.happ"
                        echo "â”‚   ${wasmExists ? 'âœ…' : 'âŒ'} holochain-cache-core WASM"

                        // Check container images in Harbor
                        echo "â”‚"
                        echo "â”‚ Container Images (Harbor):"
                        ['elohim-doorway', 'elohim-edgenode', 'elohim-happ-installer', 'elohim-app'].each { image ->
                            // Note: Would need Harbor API access to check actual tags
                            echo "â”‚   ğŸ“¦ ${image}:${branch}-latest"
                        }

                        echo """
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """
                    }
                }
            }
        }

        stage('Check Service Health') {
            when {
                expression { params.CHECK_HEALTH }
            }
            steps {
                container('builder') {
                    script {
                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ SERVICE HEALTH                                          â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        """

                        def healthResults = [:]
                        def anyUnhealthy = false

                        HEALTH_ENDPOINTS.each { name, url ->
                            def result = checkHealth(name, url)
                            healthResults[name] = result
                            def icon = result.healthy ? 'âœ…' : 'âŒ'
                            echo "â”‚ ${icon} ${name}: HTTP ${result.status}"
                            if (!result.healthy) {
                                anyUnhealthy = true
                            }
                        }

                        echo """
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """

                        if (anyUnhealthy) {
                            unstable('One or more services are unhealthy')
                        }

                        env.HEALTH_STATUS = writeJSON(returnText: true, json: healthResults)
                    }
                }
            }
        }

        stage('Dependency Analysis') {
            when {
                expression { params.FULL_REPORT }
            }
            steps {
                container('builder') {
                    script {
                        echo """
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ DEPENDENCY GRAPH                                        â”‚
                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                        â”‚                                                         â”‚
                        â”‚  elohim-holochain (DNA/hApp)                            â”‚
                        â”‚       â”‚                                                 â”‚
                        â”‚       â”œâ”€â”€â–º elohim-edge (infrastructure)                 â”‚
                        â”‚       â”‚         â”‚                                       â”‚
                        â”‚       â”œâ”€â”€â–º elohim (Angular app)                         â”‚
                        â”‚       â”‚         â”‚                                       â”‚
                        â”‚       â”‚         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                         â”‚
                        â”‚       â”‚                â”‚                                â”‚
                        â”‚       â”‚                â–¼                                â”‚
                        â”‚       â”‚         elohim-genesis (seed + test)            â”‚
                        â”‚       â”‚                                                 â”‚
                        â”‚       â””â”€â”€â–º elohim-steward (desktop, manual)             â”‚
                        â”‚                                                         â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        """
                    }
                }
            }
        }

        stage('Generate Recommendations') {
            steps {
                container('builder') {
                    script {
                        def recommendations = []
                        def branch = params.BRANCH ?: 'dev'

                        // Parse stored status
                        def pipelineStatus = readJSON(text: env.PIPELINE_STATUS ?: '{}')
                        def healthStatus = readJSON(text: env.HEALTH_STATUS ?: '{}')

                        // Check for stale builds (older than 24 hours on dev)
                        def now = System.currentTimeMillis()
                        def staleThreshold = 24 * 60 * 60 * 1000 // 24 hours

                        pipelineStatus.each { name, status ->
                            if (status.lastSuccess && status.lastSuccess != 'Never') {
                                // Would need actual timestamp comparison
                            }
                        }

                        // Check for unhealthy services
                        healthStatus.each { name, result ->
                            if (result && !result.healthy) {
                                if (name.contains('doorway')) {
                                    recommendations.add("âš ï¸ ${name} is unhealthy - run elohim-edge with FORCE_DEPLOY=true")
                                } else {
                                    recommendations.add("âš ï¸ ${name} is unhealthy - check deployment status")
                                }
                            }
                        }

                        // Check for missing artifacts
                        def happExists = getArtifactVersion('elohim-holochain', branch, 'holochain/dna/elohim/elohim.happ')
                        if (!happExists) {
                            recommendations.add("âŒ No hApp artifact for ${branch} - run elohim-holochain pipeline")
                        }

                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ğŸ“‹ RECOMMENDATIONS
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """

                        if (recommendations.isEmpty()) {
                            echo "âœ… All systems nominal - no actions required"
                        } else {
                            recommendations.each { rec ->
                                echo rec
                            }
                        }

                        echo """
                        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        """

                        // Set build description
                        def healthyCount = healthStatus.findAll { k, v -> v?.healthy }.size()
                        def totalHealth = healthStatus.size()
                        currentBuild.description = "Health: ${healthyCount}/${totalHealth} | Recommendations: ${recommendations.size()}"
                    }
                }
            }
        }
    }

    post {
        always {
            echo """
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ğŸ“Š ORCHESTRATOR COMPLETE
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Next scheduled run: ~15 minutes
            Manual trigger: Build with Parameters
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """
        }
        unstable {
            echo """
            âš ï¸ ATTENTION REQUIRED
            One or more services need attention. Check recommendations above.
            """
        }
    }
}
